CCS PCM C Compiler, Version 4.119, 93514742               25-ene-14 13:47

               Filename: D:\Marcel\Maestria\MyThesis\Proyectos\Micro\ControladorPuerta\ControladorPuerta.lst

               ROM used: 3551 words (45%)
                         Largest free fragment is 2048
               RAM used: 171 (48%) at main() level
                         192 (54%) worst case
               Stack:    7 worst case (4 in main + 3 for interrupts)

*
0000:  NOP
0001:  MOVLW  09
0002:  MOVWF  0A
0003:  GOTO   1E1
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.3
0018:  GOTO   01B
0019:  BTFSC  0B.0
001A:  GOTO   042
001B:  BTFSS  0B.4
001C:  GOTO   01F
001D:  BTFSC  0B.1
001E:  GOTO   045
001F:  MOVLW  8C
0020:  MOVWF  04
0021:  BTFSS  00.5
0022:  GOTO   025
0023:  BTFSC  0C.5
0024:  GOTO   048
0025:  MOVLW  8C
0026:  MOVWF  04
0027:  BTFSS  00.0
0028:  GOTO   02B
0029:  BTFSC  0C.0
002A:  GOTO   04B
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.1
002E:  GOTO   031
002F:  BTFSC  0C.1
0030:  GOTO   04E
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   20,W
003C:  MOVWF  0A
003D:  SWAPF  21,W
003E:  MOVWF  03
003F:  SWAPF  7F,F
0040:  SWAPF  7F,W
0041:  RETFIE
0042:  BCF    0A.3
0043:  BCF    0A.4
0044:  GOTO   277
0045:  BCF    0A.3
0046:  BCF    0A.4
0047:  GOTO   6D2
0048:  BCF    0A.3
0049:  BCF    0A.4
004A:  GOTO   2F6
004B:  BCF    0A.3
004C:  BCF    0A.4
004D:  GOTO   6DB
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   2BA
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                     
.................... #FUSES NOBROWNOUT                
.................... #FUSES NOLVP                     
.................... #use delay(clock=4000000) 
*
07DD:  MOVLW  35
07DE:  MOVWF  04
07DF:  BSF    03.7
07E0:  MOVF   00,W
07E1:  BTFSC  03.2
07E2:  GOTO   7F1
07E3:  MOVLW  01
07E4:  MOVWF  78
07E5:  CLRF   77
07E6:  DECFSZ 77,F
07E7:  GOTO   7E6
07E8:  DECFSZ 78,F
07E9:  GOTO   7E5
07EA:  MOVLW  4A
07EB:  MOVWF  77
07EC:  DECFSZ 77,F
07ED:  GOTO   7EC
07EE:  GOTO   7EF
07EF:  DECFSZ 00,F
07F0:  GOTO   7E3
07F1:  RETURN
....................  
.................... #define eeprom_address long int  
.................... #define MODBUS_TYPE MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU      
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA 
.................... #define MODBUS_ADDRESS 1 
.................... #define max_user_count 0x0F   //Este valor debe estar en 255(0xFF) en la version final 
.................... #define max_access_count 0x0F   //Este valor debe estar en 255(0xFF) en la version final 
.................... #define green_led_door_0 PIN_D1 
.................... #define green_led_door_1 PIN_A1 
.................... #define red_led_door_0 PIN_D2 
.................... #define red_led_door_1 PIN_A2 
.................... #define open_door_0 PIN_C5 
.................... #define open_door_1 PIN_A3 
.................... #define buzzer_door_0 PIN_C2 
.................... #define buzzer_door_1 PIN_A4 
....................  
.................... //#define use_external_memory 1	//Se define si se va a usar memoria externa para la lista blanca  
.................... //#define use_emulated_rtc 1	//Se define si se va a usar un rtc emulado  
....................  
.................... int seconds; 
.................... int minutes; 
.................... int hours; 
.................... int date; 
.................... int mounth; 
.................... int year_high = 20; 
.................... int year_low; 
.................... short current_door; 
.................... int user; 
.................... int time_counter = 0; 
....................  
.................... #include <wiegand.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      wiegand.c                                   //// 
.................... ////                                                                                  //// 
.................... ////             Driver para receptor/transmisor por protocolo Wiegand                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  Configuracion de HW:                                                            //// 
.................... ////                                                                                  //// 
.................... ////  Transmisor: PIN_A1 - DATA0                                                      //// 
.................... ////              PIN_A2 - DATA1                                                      //// 
.................... ////                                                                                  //// 
.................... ////  Receptor:   PIN_B4 - DATA0                                                      //// 
.................... ////              PIN_B5 - DATA1                                                      //// 
.................... ////              PIN_B6 - DATA0                                                      //// 
.................... ////              PIN_B7 - DATA1                                                      //// 
.................... ////                                                                                  //// 
.................... ////  Funciones:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  wiegand_init()                                                                  //// 
.................... ////    - Inicializacion del sistema                                                  //// 
.................... ////                                                                                  //// 
.................... ////  Receptor:                                                                       //// 
.................... ////  receive_wiegand()                                                               //// 
.................... ////    - Devuelve true si ha arrivado algun codigo wiegand                           //// 
.................... ////                                                                                  //// 
.................... ////  get_code(int &facCode, long &userCode)                                          //// 
.................... ////    - Devuelve el valor del ultimo codigo Wiegand arrivado en el facCode y el     //// 
.................... ////      userCode                                                                    //// 
.................... ////                                                                                  //// 
.................... ////  get_door()                                                                      //// 
.................... ////    - Devuelve la puerta correspondiente al lector por donde llego el codigo      //// 
.................... ////      Wiegand                                                                     //// 
.................... ////                                                                                  //// 
.................... ////  Transmisor:                                                                     //// 
.................... ////  send_wiegand(int facCode, long userCode)                                        //// 
.................... ////    - Envia wiegand el codigo especificado                                        //// 
.................... ////                                                                                  //// 
.................... ////  Nota:                                                                           //// 
.................... ////  Si se va a usar como transmisor, debe definirse la constante                    ////   
.................... ////  WIEGAND_TYPE_TRANSMITER                                                         //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //Variables globales a usarse fundamentalmente en las subrutinas de interrupcion  
.................... int facCode; 
.................... long userCode = 0; 
.................... int wiegand_counter = 0;   //contador de bits de codigo Wiegand  
....................  
.................... #ifndef WIEGAND_TYPE_TRANSMITER     //RECEPTOR por definicion 
....................  
.................... #define CodeBits 26 
.................... short read_complete = 0;   //bandera de lectura terminada 
.................... int buffer[CodeBits];   //buffer del codigo Wiegand que llega 
.................... int reading;   //lectura del puerto de protocolo Wiegand 
.................... short door; 
....................  
.................... //Funcion para limpiar (poner en cero) el buffer de codigo  
.................... void clean_buffer() 
.................... { 
....................    int i; 
....................    for(i = 0; i < CodeBits; i++)  
*
071E:  BSF    03.6
071F:  CLRF   34
0720:  MOVF   34,W
0721:  SUBLW  19
0722:  BTFSS  03.0
0723:  GOTO   72B
....................       buffer[i] = 0x00; 
0724:  MOVLW  36
0725:  ADDWF  34,W
0726:  MOVWF  04
0727:  BCF    03.7
0728:  CLRF   00
0729:  INCF   34,F
072A:  GOTO   720
....................    wiegand_counter = 0; 
072B:  BCF    03.6
072C:  CLRF   35
.................... } 
072D:  RETURN
....................  
.................... //Funcion que obtiene el FacilityCode y el UserCode a partir del buffer de codigo 
.................... void code_update() 
.................... { 
....................    int i; 
....................    //Facility Code 
....................    facCode = 0x00; 
*
08DD:  CLRF   32
....................    long multiplo = 1;   //variable para las potencias de 2 para formar el numero a partir de los 0s y 1s del buffer 
08DE:  BSF    03.6
08DF:  CLRF   36
08E0:  MOVLW  01
08E1:  MOVWF  35
....................    for(i = 1; i < 9; i++){   //El FacilityCode esta en el primer byte del buffer  
08E2:  MOVWF  34
08E3:  MOVF   34,W
08E4:  SUBLW  08
08E5:  BTFSS  03.0
08E6:  GOTO   0F6
....................       if(buffer[i] == 1) 
08E7:  MOVLW  36
08E8:  ADDWF  34,W
08E9:  MOVWF  04
08EA:  BCF    03.7
08EB:  DECFSZ 00,W
08EC:  GOTO   0F1
....................          facCode += multiplo; 
08ED:  MOVF   35,W
08EE:  BCF    03.6
08EF:  ADDWF  32,F
08F0:  BSF    03.6
....................       multiplo *= 2; 
08F1:  BCF    03.0
08F2:  RLF    35,F
08F3:  RLF    36,F
....................    } 
08F4:  INCF   34,F
08F5:  GOTO   0E3
....................    //User Code 
....................    userCode = 0x00; 
08F6:  BCF    03.6
08F7:  CLRF   34
08F8:  CLRF   33
....................    multiplo = 1; 
08F9:  BSF    03.6
08FA:  CLRF   36
08FB:  MOVLW  01
08FC:  MOVWF  35
....................    for(i = 9; i < 25; i++){   //El userCode esta en los restantes 16 bits del buffer 
08FD:  MOVLW  09
08FE:  MOVWF  34
08FF:  MOVF   34,W
0900:  SUBLW  18
0901:  BTFSS  03.0
0902:  GOTO   11A
....................       if(buffer[i] == 1) 
0903:  MOVLW  36
0904:  ADDWF  34,W
0905:  MOVWF  04
0906:  BCF    03.7
0907:  DECFSZ 00,W
0908:  GOTO   115
....................          userCode += multiplo; 
0909:  MOVF   35,W
090A:  BCF    03.6
090B:  ADDWF  33,F
090C:  BSF    03.6
090D:  MOVF   36,W
090E:  BTFSC  03.0
090F:  INCFSZ 36,W
0910:  GOTO   112
0911:  GOTO   115
0912:  BCF    03.6
0913:  ADDWF  34,F
0914:  BSF    03.6
....................       multiplo *= 2; 
0915:  BCF    03.0
0916:  RLF    35,F
0917:  RLF    36,F
....................    } 
0918:  INCF   34,F
0919:  GOTO   0FF
.................... } 
....................  
.................... //Funcion que chequea la paridad en el codigo Wiegand arribado 
.................... short check_parity() 
.................... { 
....................    int sum = 0;   //para contar los 1s del codigo 
....................    int i; 
....................    //Comprobando 1ra mitad del codigo Wiegand 
....................    for(i = 0; i < 13; i++){     
....................       if(buffer[i] == 1) 
....................          sum++; 
....................     } 
....................    //sum += first_parity; 
....................    //Comprobando paridad par 
....................    if(sum & 1) 
....................       return 0; 
....................     
....................    sum = 0;   //reinicio el contador 
....................    //Comprobando 2da mitad del codigo Wiegand 
....................    for(i = 13; i < 26; i++){     
....................       if(buffer[i] == 1) 
....................          sum++; 
....................     } 
....................    //sum += last_parity; 
....................    //Comprobando paridad impar 
....................    if(sum & 1) 
....................       return 1; 
....................     
....................    return 0; 
.................... } 
....................  
.................... //Funcion que actualiza el buffer del codigo Wiegand 
.................... void buffer_update(short value, short currentDoor) 
.................... { 
....................     buffer[wiegand_counter] = value; 
*
025F:  MOVLW  36
0260:  ADDWF  35,W
0261:  MOVWF  04
0262:  BCF    03.7
0263:  BSF    03.6
0264:  MOVF   42,W
0265:  MOVWF  00
....................     wiegand_counter++; 
0266:  BCF    03.6
0267:  INCF   35,F
....................     if(wiegand_counter == CodeBits){ 
0268:  MOVF   35,W
0269:  SUBLW  1A
026A:  BTFSS  03.2
026B:  GOTO   276
....................         read_complete = 1; 
026C:  BSF    2F.1
....................         door = currentDoor; 
026D:  BCF    2F.2
026E:  BSF    03.6
026F:  BTFSS  43.0
0270:  GOTO   274
0271:  BCF    03.6
0272:  BSF    2F.2
0273:  BSF    03.6
....................         disable_interrupts(int_rb); 
0274:  BCF    03.6
0275:  BCF    0B.3
....................     } 
.................... } 
0276:  RETURN
....................  
.................... short receive_wiegand() 
.................... { 
....................    if(read_complete){ 
*
08DA:  BTFSS  2F.1
08DB:  GOTO   122
....................       //if(check_parity()){ 
....................          read_complete = 0; 
08DC:  BCF    2F.1
....................          code_update(); 
....................          clean_buffer(); 
*
091A:  BCF    0A.3
091B:  BCF    03.6
091C:  CALL   71E
091D:  BSF    0A.3
....................          enable_interrupts(int_rb); 
091E:  BSF    0B.3
....................          return 1; 
091F:  MOVLW  01
0920:  MOVWF  78
0921:  GOTO   124
....................       //} 
....................    } 
....................    return 0; 
0922:  MOVLW  00
0923:  MOVWF  78
.................... } 
0924:  BSF    0A.3
0925:  BCF    0A.4
0926:  GOTO   2EC (RETURN)
....................  
.................... void get_code(int &_facCode, long &_userCode) 
.................... { 
....................    _facCode = facCode; 
*
0B26:  MOVF   32,W
0B27:  BSF    03.6
0B28:  MOVWF  30
....................    _userCode = userCode; 
0B29:  BCF    03.6
0B2A:  MOVF   34,W
0B2B:  BSF    03.6
0B2C:  MOVWF  32
0B2D:  BCF    03.6
0B2E:  MOVF   33,W
0B2F:  BSF    03.6
0B30:  MOVWF  31
.................... } 
....................  
.................... short get_door() 
.................... { 
....................    return door; 
*
07D6:  MOVLW  00
07D7:  BTFSC  2F.2
07D8:  MOVLW  01
07D9:  MOVWF  78
.................... } 
07DA:  BSF    0A.3
07DB:  BCF    0A.4
07DC:  GOTO   2F1 (RETURN)
....................  
.................... //Interrupcion por cambio de estado en los pines RB4-RB7 
.................... #int_rb       
.................... void ext_handler() 
.................... { 
....................    reading = input_b(); 
*
0277:  MOVLW  FF
0278:  BSF    03.5
0279:  MOVWF  06
027A:  BCF    03.5
027B:  MOVF   06,W
027C:  MOVWF  50
....................     
....................    //Determinando el pin del puerto B por donde se produjo el pulso  
....................    switch(reading){ 
027D:  MOVF   50,W
027E:  XORLW  EF
027F:  BTFSC  03.2
0280:  GOTO   28B
0281:  XORLW  30
0282:  BTFSC  03.2
0283:  GOTO   291
0284:  XORLW  60
0285:  BTFSC  03.2
0286:  GOTO   298
0287:  XORLW  C0
0288:  BTFSC  03.2
0289:  GOTO   29F
028A:  GOTO   2A6
....................       case 0xEF:   //RB4 = data0 puerta0 
....................          buffer_update(0, 0); 
028B:  BSF    03.6
028C:  CLRF   42
028D:  CLRF   43
028E:  BCF    03.6
028F:  CALL   25F
....................          break;       
0290:  GOTO   2A6
....................       case 0xDF:   //RB5 = data1 puerta0 
....................          buffer_update(1, 0); 
0291:  MOVLW  01
0292:  BSF    03.6
0293:  MOVWF  42
0294:  CLRF   43
0295:  BCF    03.6
0296:  CALL   25F
....................          break; 
0297:  GOTO   2A6
....................       case 0xBF:   //RB6 = data0 puerta1 
....................          buffer_update(0, 1); 
0298:  BSF    03.6
0299:  CLRF   42
029A:  MOVLW  01
029B:  MOVWF  43
029C:  BCF    03.6
029D:  CALL   25F
....................          break; 
029E:  GOTO   2A6
....................       case 0x7F:   //RB7 = data1 puerta1 
....................          buffer_update(1, 1); 
029F:  MOVLW  01
02A0:  BSF    03.6
02A1:  MOVWF  42
02A2:  MOVWF  43
02A3:  BCF    03.6
02A4:  CALL   25F
....................          break; 
02A5:  GOTO   2A6
....................    } 
.................... } 
....................  
.................... #else    //TRANSMISOR 
....................  
.................... long position = 1;   //para crear la potencia de 2 y determinar el numero con 1 en el bit que interesa 
.................... short first_parity; 
.................... short last_parity; 
....................  
.................... //Funcion que realiza el pulso de 50us en el data0 o data1 segun corresponda 
.................... void pulse(short pin) 
.................... { 
....................     output_low(pin); 
....................     delay_us(50); 
....................     output_high(pin); 
....................     wiegand_counter++;      //actualizando el contador de bits del codigo Wiegand 
.................... } 
....................  
.................... //Funcion que determina la posicion o bit del codigo (facCode o userCode) que toca y realiza el pulso 
.................... void position_pulse(long code) 
.................... { 
....................     if(code & position)   //si el bit en turno es 1 hago pulso por el data1    
....................       pulse(PIN_A2); 
....................     else   //si el bit en turno es 0 hago pulso por el data0 
....................       pulse(PIN_A1); 
....................          
....................     position *= 2;   //pasando el 1 al siguiente bit    
.................... } 
....................  
.................... //Interrupcion por el timer0 cada 2ms para el protocolo Wiegand 
.................... #int_timer0 
.................... void timer0() 
.................... { 
....................      if(wiegand_counter == 0){    
....................      //primer bit de paridad  
....................        if(first_parity) 
....................          pulse(PIN_A2); 
....................        else 
....................          pulse(PIN_A1);    
....................      } 
....................       
....................       else if(wiegand_counter < 9)   //nos encontramos en la seccion del facCode 
....................          position_pulse(facCode); 
....................           
....................       else if(wiegand_counter < 25){   //nos encontramos en la seccion del userCode 
....................          if(wiegand_counter == 9)   //nos encontramos en el inicio de la seccion  
....................             position = 1;  //hay que reiniciar la posicion del bit a comparar 
....................          position_pulse(userCode); 
....................       } 
....................        
....................       else{      //nos encontramos en el final del codigo, por tanto ya se termino de transmitir 
....................        
....................          //ultimo bit de paridad  
....................          if(last_parity) 
....................             pulse(PIN_A2); 
....................          else 
....................             pulse(PIN_A1);    
....................           
....................          disable_interrupts(INT_TIMER0); 
....................          wiegand_counter = 0; 
....................          position = 1; 
....................       } 
....................       set_timer0(6);   //recargando el timer 
.................... } 
....................  
.................... //Funcion que completa los bits de paridad del codigo Wiegand(modificar first_parity y last_parity) 
.................... void build_parity() 
.................... { 
....................    long code; 
....................    long i;  
....................    int parity = 0; 
....................    first_parity = 0; 
....................    last_parity = 1; 
....................     
....................    //Obteniendo la paridad par de los primeros 12 bits (los 8 del facCode mas los 4 mas significativos del userCode) 
....................    for(i = 1; i <= 128; i *= 2){ 
....................       if(i & facCode) 
....................          parity++; 
....................    } 
....................    code = userCode >> 12; 
....................    for(i = 1; i <= 16; i *= 2){ 
....................       if(i & code) 
....................          parity++; 
....................    } 
....................    if(parity & 1) 
....................       first_parity = 1; 
....................        
....................    //Obteniendo la paridad impar de los ultimos 12 bits (12 bits menos significativos del userCode)    
....................    parity = 0; 
....................    for(i = 1; i <= 2048; i *= 2){ 
....................       if(i & userCode) 
....................          parity++; 
....................    } 
....................    if(parity & 1) 
....................       last_parity = 0; 
.................... } 
....................  
.................... void send_wiegand(int _facCode, long _userCode) 
.................... { 
....................    facCode = _facCode; 
....................    userCode = _userCode; 
....................    build_parity(); 
....................    enable_interrupts(INT_TIMER0); 
.................... } 
....................  
.................... #endif 
....................  
02A6:  BCF    0B.0
02A7:  BCF    0A.3
02A8:  BCF    0A.4
02A9:  GOTO   031
.................... void wiegand_init() 
.................... { 
....................    #ifndef WIEGAND_TYPE_TRANSMITER 
....................    clean_buffer(); 
*
072E:  CALL   71E
....................    port_b_pullups(TRUE); 
072F:  BSF    03.5
0730:  BCF    01.7
....................    enable_interrupts(int_rb); 
0731:  BCF    03.5
0732:  BSF    0B.3
....................    #else 
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_8); 
....................    set_timer0(6);   //2ms 
....................    wiegand_counter = 0; 
....................    position = 1; 
....................    #endif 
....................    enable_interrupts(GLOBAL); 
0733:  MOVLW  C0
0734:  IORWF  0B,F
.................... } 
0735:  BSF    0A.3
0736:  BCF    0A.4
0737:  GOTO   210 (RETURN)
....................  
.................... #include <modbus.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      modbus.c                                    //// 
.................... ////                                                                                  //// 
.................... ////                 MODBUS protocol driver for serial communications.                //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////                                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// SHARED API:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... //// MASTER API:                                                                      //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////                                                                                  //// 
.................... //// Slave API:                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
....................  
.................... #ifndef MODBUS_TYPE 
.................... #define MODBUS_TYPE MODBUS_TYPE_MASTER 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TYPE 
.................... #define MODBUS_SERIAL_TYPE MODBUS_RTU 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_INT_SOURCE 
.................... #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA    // Select between external interrupt 
.................... #endif                                             // or asynchronous serial interrupt 
....................  
.................... #ifndef MODBUS_SERIAL_BAUD 
.................... #define MODBUS_SERIAL_BAUD 9600 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_PIN 
.................... #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TX_PIN 
.................... #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_ENABLE_PIN 
.................... #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_TIMEOUT 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       #define MODBUS_SERIAL_TIMEOUT    1000000 
....................    #else 
....................       #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................    #endif 
.................... #endif 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
*
02D9:  BTFSS  0C.5
02DA:  GOTO   2D9
02DB:  MOVF   18,W
02DC:  MOVWF  51
02DD:  MOVF   1A,W
02DE:  MOVWF  78
02DF:  BTFSS  51.1
02E0:  GOTO   2E3
02E1:  BCF    18.4
02E2:  BSF    18.4
02E3:  RETURN
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, errors) 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
.................... #endif 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................  
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................     if(address)\ 
....................     {\ 
....................         while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................             delay_us(1);\ 
....................         if(!modbus_serial_wait)\ 
....................             modbus_rx.error=TIMEOUT;\ 
....................     }\ 
....................     modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA")  
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #byte TXSTA=getenv("sfr:TXSTA2") 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
....................  
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... }    
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions.   
.................... The first exception is the only one that is not part of the protocol  
.................... specification.  The TIMEOUT exception is returned when no slave  
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2,  
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6,  
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See  
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................      
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    enum {MODBUS_START=0, MODBUS_GETADDY, MODBUS_GETFUNC, MODBUS_GETDATA, MODBUS_STOP} modbus_serial_state=0; 
.................... #else 
....................    enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
.................... #endif 
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................    unsigned int8 modbus_serial_lrc; 
.................... #else 
....................    union 
....................    { 
....................       unsigned int8 b[2]; 
....................       unsigned int16 d; 
....................    } modbus_serial_crc; 
.................... #endif 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see  
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
.................... #endif 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
0706:  BTFSS  0C.5
0707:  GOTO   70A
0708:  CALL   2D9
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
0709:  GOTO   706
....................         clear_interrupt(INT_RDA); 
070A:  BCF    0C.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         clear_interrupt(INT_RDA3); 
....................       #else 
....................         clear_interrupt(INT_RDA4); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
070B:  BSF    03.5
070C:  BSF    0C.5
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #else 
....................         enable_interrupts(INT_RDA4); 
....................       #endif 
....................    #else 
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................        
....................       ext_int_edge(H_TO_L); 
....................       
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0)  
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
070D:  BCF    03.5
070E:  RETURN
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
070F:  BCF    00.0
....................  
....................    RCV_ON(); 
0710:  CALL   706
....................  
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer2(TMR_INTERNAL | TMR_DIV_BY_8,4999); //~4ms interrupts for 20Mhz clock 
....................       #endif 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................          setup_timer_2(T2_DIV_BY_16,249,5);  //~4ms interrupts 
0711:  MOVLW  20
0712:  MOVWF  78
0713:  IORLW  06
0714:  MOVWF  12
0715:  MOVLW  F9
0716:  BSF    03.5
0717:  MOVWF  12
....................       #endif 
....................       enable_interrupts(GLOBAL); 
0718:  MOVLW  C0
0719:  BCF    03.5
071A:  IORWF  0B,F
....................    #endif 
.................... } 
071B:  BSF    0A.3
071C:  BCF    0A.4
071D:  GOTO   20D (RETURN)
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    disable_interrupts(INT_TIMER2); 
*
02AA:  BSF    03.5
02AB:  BCF    0C.1
....................    if (enable) { 
02AC:  BCF    03.5
02AD:  BSF    03.6
02AE:  MOVF   43,F
02AF:  BTFSC  03.2
02B0:  GOTO   2B8
....................       set_timer2(0); 
02B1:  BCF    03.6
02B2:  CLRF   11
....................       clear_interrupt(INT_TIMER2); 
02B3:  BCF    0C.1
....................       enable_interrupts(INT_TIMER2); 
02B4:  BSF    03.5
02B5:  BSF    0C.1
02B6:  BCF    03.5
02B7:  BSF    03.6
....................    } 
.................... } 
02B8:  BCF    03.6
02B9:  RETURN
.................... #endif 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    #int_timer2 
....................    void modbus_timeout_now(void) 
....................    { 
....................       if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
02BA:  MOVF   52,W
02BB:  SUBLW  02
02BC:  BTFSS  03.2
02BD:  GOTO   2CC
02BE:  MOVF   53,F
02BF:  BTFSS  03.2
02C0:  GOTO   2CC
02C1:  MOVF   54,F
02C2:  BTFSS  03.2
02C3:  GOTO   2CC
02C4:  BTFSC  2F.3
02C5:  GOTO   2CC
....................       { 
....................          modbus_rx.len-=2; 
02C6:  MOVLW  02
02C7:  BSF    03.5
02C8:  SUBWF  21,F
....................          modbus_serial_new=TRUE; 
02C9:  BCF    03.5
02CA:  BSF    2F.3
....................       } 
....................       else 
02CB:  GOTO   2CD
....................          modbus_serial_new=FALSE; 
02CC:  BCF    2F.3
....................     
....................       modbus_serial_crc.d=0xFFFF; 
02CD:  MOVLW  FF
02CE:  MOVWF  54
02CF:  MOVWF  53
....................       modbus_serial_state=MODBUS_GETADDY; 
02D0:  CLRF   52
....................       modbus_enable_timeout(FALSE); 
02D1:  BSF    03.6
02D2:  CLRF   43
02D3:  BCF    03.6
02D4:  CALL   2AA
....................    } 
.................... #endif 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
02D5:  BCF    0C.1
02D6:  BCF    0A.3
02D7:  BCF    0A.4
02D8:  GOTO   031
.................... void modbus_calc_crc(char data) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc+=data; 
....................    #else 
....................       unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................       uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
02E4:  MOVF   54,W
02E5:  BSF    03.6
02E6:  XORWF  43,W
02E7:  MOVWF  44
....................       modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
02E8:  MOVF   44,W
02E9:  BCF    03.6
02EA:  CALL   051
02EB:  MOVWF  78
02EC:  MOVF   53,W
02ED:  XORWF  78,W
02EE:  MOVWF  54
....................       modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
02EF:  BSF    03.6
02F0:  MOVF   44,W
02F1:  BCF    03.6
02F2:  CALL   158
02F3:  MOVWF  78
02F4:  MOVWF  53
....................    #endif 
.................... } 
02F5:  RETURN
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       unsigned int8 asciih,asciil; 
....................        
....................       asciih=c>>4; 
....................       if(asciih>9) 
....................          asciih+=0x37; 
....................       else 
....................          asciih+=0x30; 
....................       asciil=c&0xF; 
....................       if(asciil>9) 
....................          asciil+=0x37; 
....................       else 
....................          asciil+=0x30; 
....................       fputc(asciih,MODBUS_SERIAL); 
....................       fputc(asciil,MODBUS_SERIAL); 
....................       modbus_calc_crc(c); 
....................    #else 
....................       fputc(c, MODBUS_SERIAL); 
*
093B:  BSF    03.6
093C:  MOVF   3F,W
093D:  BCF    03.6
093E:  BTFSS  0C.4
093F:  GOTO   13E
0940:  MOVWF  19
0941:  CLRF   27
0942:  BTFSC  0B.7
0943:  BSF    27.7
0944:  BCF    0B.7
....................       modbus_calc_crc(c); 
0945:  BSF    03.6
0946:  MOVF   3F,W
0947:  MOVWF  43
0948:  BCF    0A.3
0949:  BCF    03.6
094A:  CALL   2E4
094B:  BSF    0A.3
094C:  BTFSC  27.7
094D:  BSF    0B.7
....................       delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
094E:  MOVLW  22
094F:  MOVWF  77
0950:  DECFSZ 77,F
0951:  GOTO   150
0952:  NOP
....................    #endif 
.................... } 
0953:  RETURN
....................  
.................... // Purpose:   Interrupt service routine for handling incoming serial data 
.................... // Inputs:    None 
.................... // Outputs:   None 
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext0 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
....................    char c; 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       static int1 two_characters=0; 
....................       static unsigned int8 datah,datal,data; 
....................    #endif 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
*
02F6:  CALL   2D9
02F7:  MOVF   78,W
02F8:  BSF    03.6
02F9:  MOVWF  42
....................     
....................    if (!modbus_serial_new) 
02FA:  BCF    03.6
02FB:  BTFSC  2F.3
02FC:  GOTO   33A
....................    { 
....................       #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................          if(modbus_serial_state == MODBUS_START) 
....................          { 
....................             if(c==':') 
....................                modbus_serial_state++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETADDY) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                modbus_serial_lrc=0; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.address=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
....................          { 
....................             if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                modbus_rx.func=data; 
....................                modbus_calc_crc(data); 
....................                modbus_serial_state++; 
....................                modbus_rx.len=0; 
....................                modbus_rx.error=0; 
....................             } 
....................             two_characters++; 
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
....................          { 
....................             if(c=='\r') 
....................             { 
....................                modbus_serial_state++; 
....................                modbus_rx.len--; 
....................                modbus_serial_lrc-=data; 
....................             } 
....................             else if(!two_characters) 
....................             { 
....................                if(c>=0x41) 
....................                   datah=((c-0x37)<<4); 
....................                else 
....................                   datah=((c-0x30)<<4); 
....................                two_characters++; 
....................             } 
....................             else 
....................             { 
....................                if(c>=0x41) 
....................                   datal=c-0x37; 
....................                else 
....................                   datal=c-0x30; 
....................                data=(datah | datal); 
....................                if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
....................                   modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
....................                modbus_rx.data[modbus_rx.len]=data; 
....................                modbus_rx.len++; 
....................                modbus_calc_crc(data); 
....................                two_characters++; 
....................             } 
....................          } 
....................          else if(modbus_serial_state==MODBUS_STOP) 
....................          { 
....................             if(c=='\n') 
....................             { 
....................                modbus_serial_lrc=((0xFF-modbus_serial_lrc)+1); 
....................                if(modbus_serial_lrc==data) 
....................                   modbus_serial_new=TRUE; 
....................             } 
....................             modbus_serial_state=MODBUS_START; 
....................             two_characters=0; 
....................          } 
....................       #else 
....................              
....................          if(modbus_serial_state == MODBUS_GETADDY) 
02FD:  MOVF   52,F
02FE:  BTFSS  03.2
02FF:  GOTO   30F
....................          { 
....................             modbus_serial_crc.d = 0xFFFF; 
0300:  MOVLW  FF
0301:  MOVWF  54
0302:  MOVWF  53
....................             modbus_rx.address = c; 
0303:  BSF    03.6
0304:  MOVF   42,W
0305:  BSF    03.5
0306:  BCF    03.6
0307:  MOVWF  20
....................             modbus_serial_state++; 
0308:  BCF    03.5
0309:  INCF   52,F
....................             modbus_rx.len = 0; 
030A:  BSF    03.5
030B:  CLRF   21
....................             modbus_rx.error=0; 
030C:  CLRF   23
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETFUNC) 
030D:  GOTO   32F
030E:  BCF    03.5
030F:  DECFSZ 52,W
0310:  GOTO   319
....................          { 
....................             modbus_rx.func = c; 
0311:  BSF    03.6
0312:  MOVF   42,W
0313:  BSF    03.5
0314:  BCF    03.6
0315:  MOVWF  22
....................             modbus_serial_state++; 
0316:  BCF    03.5
0317:  INCF   52,F
....................          } 
....................          else if(modbus_serial_state == MODBUS_GETDATA) 
0318:  GOTO   330
0319:  MOVF   52,W
031A:  SUBLW  02
031B:  BTFSS  03.2
031C:  GOTO   330
....................          { 
....................             if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) {modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1;} 
031D:  BSF    03.5
031E:  MOVF   21,W
031F:  SUBLW  3F
0320:  BTFSC  03.0
0321:  GOTO   324
0322:  MOVLW  3F
0323:  MOVWF  21
....................             modbus_rx.data[modbus_rx.len]=c; 
0324:  MOVLW  A4
0325:  ADDWF  21,W
0326:  MOVWF  04
0327:  BCF    03.7
0328:  BCF    03.5
0329:  BSF    03.6
032A:  MOVF   42,W
032B:  MOVWF  00
....................             modbus_rx.len++; 
032C:  BSF    03.5
032D:  BCF    03.6
032E:  INCF   21,F
032F:  BCF    03.5
....................          } 
....................     
....................          modbus_calc_crc(c); 
0330:  BSF    03.6
0331:  MOVF   42,W
0332:  MOVWF  43
0333:  BCF    03.6
0334:  CALL   2E4
....................          modbus_enable_timeout(TRUE); 
0335:  MOVLW  01
0336:  BSF    03.6
0337:  MOVWF  43
0338:  BCF    03.6
0339:  CALL   2AA
....................       #endif 
....................    } 
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
033A:  BCF    0C.5
033B:  BCF    0A.3
033C:  BCF    0A.4
033D:  GOTO   031
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func) 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
*
0954:  MOVLW  FF
0955:  MOVWF  54
0956:  MOVWF  53
....................    #endif 
....................    modbus_serial_new=FALSE; 
0957:  BCF    2F.3
....................  
....................    RCV_OFF(); 
0958:  BSF    03.5
0959:  BCF    0C.5
....................     
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE==MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
095A:  MOVLW  79
095B:  MOVWF  77
095C:  DECFSZ 77,F
095D:  GOTO   15C
....................    #else 
....................       fputc(':',MODBUS_SERIAL); 
....................    #endif 
....................  
....................    modbus_serial_putc(to); 
095E:  BCF    03.5
095F:  BSF    03.6
0960:  MOVF   3D,W
0961:  MOVWF  3F
0962:  BCF    03.6
0963:  CALL   13B
....................    modbus_serial_putc(func); 
0964:  BSF    03.6
0965:  MOVF   3E,W
0966:  MOVWF  3F
0967:  BCF    03.6
0968:  CALL   13B
.................... } 
0969:  RETURN
....................  
.................... void modbus_serial_send_stop() 
.................... { 
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       int8 i; 
....................        
....................       for(i=0;i<8;i++) 
....................       { 
....................          if(bit_test(modbus_serial_lrc,i)) 
....................             bit_clear(modbus_serial_lrc,i); 
....................          else 
....................             bit_set(modbus_serial_lrc,i); 
....................       } 
....................       modbus_serial_lrc++; 
....................        
....................       modbus_serial_putc(modbus_serial_lrc); 
....................       fputc('\r',MODBUS_SERIAL); 
....................       fputc('\n',MODBUS_SERIAL); 
....................    #else 
....................       unsigned int8 crc_low, crc_high; 
....................     
....................       crc_high=modbus_serial_crc.b[1]; 
096A:  MOVF   54,W
096B:  BSF    03.6
096C:  MOVWF  3E
....................       crc_low=modbus_serial_crc.b[0]; 
096D:  BCF    03.6
096E:  MOVF   53,W
096F:  BSF    03.6
0970:  MOVWF  3D
....................     
....................       modbus_serial_putc(crc_high); 
0971:  MOVF   3E,W
0972:  MOVWF  3F
0973:  BCF    03.6
0974:  CALL   13B
....................       modbus_serial_putc(crc_low); 
0975:  BSF    03.6
0976:  MOVF   3D,W
0977:  MOVWF  3F
0978:  BCF    03.6
0979:  CALL   13B
....................    #endif 
....................     
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
097A:  BSF    03.5
097B:  BTFSS  18.1
097C:  GOTO   17B
.................... #endif 
....................     
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................       delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
097D:  MOVLW  79
097E:  MOVWF  77
097F:  DECFSZ 77,F
0980:  GOTO   17F
....................    #endif 
....................  
....................    RCV_ON(); 
0981:  BCF    0A.3
0982:  BCF    03.5
0983:  CALL   706
0984:  BSF    0A.3
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0)  
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
.................... #endif 
....................  
....................    #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................       modbus_serial_lrc=0; 
....................    #else 
....................       modbus_serial_crc.d=0xFFFF; 
0985:  MOVLW  FF
0986:  MOVWF  54
0987:  MOVWF  53
....................    #endif 
.................... } 
0988:  RETURN
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    if(!modbus_serial_new) 
*
0927:  BTFSC  2F.3
0928:  GOTO   12D
....................       return FALSE; 
0929:  MOVLW  00
092A:  MOVWF  78
092B:  GOTO   138
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
092C:  GOTO   135
092D:  BSF    03.5
092E:  BTFSS  22.7
092F:  GOTO   134
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
0930:  MOVF   24,W
0931:  MOVWF  23
....................       modbus_rx.len = 1; 
0932:  MOVLW  01
0933:  MOVWF  21
0934:  BCF    03.5
....................    } 
....................    modbus_serial_new=FALSE; 
0935:  BCF    2F.3
....................    return TRUE; 
0936:  MOVLW  01
0937:  MOVWF  78
.................... } 
0938:  BSF    0A.3
0939:  BCF    0A.4
093A:  GOTO   3CA (RETURN)
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... /*MODBUS Master Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................        
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................     
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................     
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................     
....................    count = (unsigned int8)((quantity/8)); 
....................     
....................    if(quantity%8) 
....................       count++;       
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i)  
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................     
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................     
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count,  
....................                             modbus_read_sub_request *request) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count,  
....................                             modbus_write_sub_request *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) &&  
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((unsigned int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... /*MODBUS Slave Functions*/ 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*coil_data); 
....................       coil_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count,  
....................                                     unsigned int8 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; ++i) 
....................    { 
....................       modbus_serial_putc(*input_data); 
....................       input_data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count,  
....................                                         unsigned int16 *reg_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
*
0C3F:  MOVF   35,W
0C40:  MOVWF  3D
0C41:  MOVLW  03
0C42:  MOVWF  3E
0C43:  BCF    03.6
0C44:  CALL   154
....................  
....................    modbus_serial_putc(byte_count); 
0C45:  BSF    03.6
0C46:  MOVF   36,W
0C47:  MOVWF  3F
0C48:  BCF    03.6
0C49:  CALL   13B
....................  
....................    for(i=0; i < byte_count; i+=2) 
0C4A:  BSF    03.6
0C4B:  CLRF   39
0C4C:  MOVF   36,W
0C4D:  SUBWF  39,W
0C4E:  BTFSC  03.0
0C4F:  GOTO   47C
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
0C50:  MOVF   38,W
0C51:  MOVWF  7A
0C52:  MOVF   37,W
0C53:  MOVWF  04
0C54:  BCF    03.7
0C55:  BTFSC  38.0
0C56:  BSF    03.7
0C57:  INCF   04,F
0C58:  MOVF   00,W
0C59:  MOVWF  3B
0C5A:  DECF   04,F
0C5B:  MOVF   00,W
0C5C:  MOVWF  3A
0C5D:  MOVF   3B,W
0C5E:  MOVWF  3C
0C5F:  MOVWF  3F
0C60:  BCF    03.6
0C61:  CALL   13B
....................       modbus_serial_putc(make8(*reg_data,0)); 
0C62:  BSF    03.6
0C63:  MOVF   38,W
0C64:  MOVWF  7A
0C65:  MOVF   37,W
0C66:  MOVWF  04
0C67:  BCF    03.7
0C68:  BTFSC  38.0
0C69:  BSF    03.7
0C6A:  INCF   04,F
0C6B:  MOVF   00,W
0C6C:  MOVWF  3B
0C6D:  DECF   04,F
0C6E:  MOVF   00,W
0C6F:  MOVWF  3A
0C70:  MOVWF  3C
0C71:  MOVWF  3F
0C72:  BCF    03.6
0C73:  CALL   13B
....................       reg_data++; 
0C74:  MOVLW  02
0C75:  BSF    03.6
0C76:  ADDWF  37,F
0C77:  BTFSC  03.0
0C78:  INCF   38,F
....................    } 
0C79:  MOVLW  02
0C7A:  ADDWF  39,F
0C7B:  GOTO   44C
....................  
....................    modbus_serial_send_stop(); 
0C7C:  BCF    03.6
0C7D:  CALL   16A
0C7E:  NOP
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count,  
....................                                         unsigned int16 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
*
0C9B:  MOVF   35,W
0C9C:  MOVWF  3D
0C9D:  MOVLW  04
0C9E:  MOVWF  3E
0C9F:  BCF    03.6
0CA0:  CALL   154
....................  
....................    modbus_serial_putc(byte_count); 
0CA1:  BSF    03.6
0CA2:  MOVF   36,W
0CA3:  MOVWF  3F
0CA4:  BCF    03.6
0CA5:  CALL   13B
....................  
....................    for(i=0; i < byte_count; i+=2) 
0CA6:  BSF    03.6
0CA7:  CLRF   39
0CA8:  MOVF   36,W
0CA9:  SUBWF  39,W
0CAA:  BTFSC  03.0
0CAB:  GOTO   4D8
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
0CAC:  MOVF   38,W
0CAD:  MOVWF  7A
0CAE:  MOVF   37,W
0CAF:  MOVWF  04
0CB0:  BCF    03.7
0CB1:  BTFSC  38.0
0CB2:  BSF    03.7
0CB3:  INCF   04,F
0CB4:  MOVF   00,W
0CB5:  MOVWF  3B
0CB6:  DECF   04,F
0CB7:  MOVF   00,W
0CB8:  MOVWF  3A
0CB9:  MOVF   3B,W
0CBA:  MOVWF  3C
0CBB:  MOVWF  3F
0CBC:  BCF    03.6
0CBD:  CALL   13B
....................       modbus_serial_putc(make8(*input_data,0)); 
0CBE:  BSF    03.6
0CBF:  MOVF   38,W
0CC0:  MOVWF  7A
0CC1:  MOVF   37,W
0CC2:  MOVWF  04
0CC3:  BCF    03.7
0CC4:  BTFSC  38.0
0CC5:  BSF    03.7
0CC6:  INCF   04,F
0CC7:  MOVF   00,W
0CC8:  MOVWF  3B
0CC9:  DECF   04,F
0CCA:  MOVF   00,W
0CCB:  MOVWF  3A
0CCC:  MOVWF  3C
0CCD:  MOVWF  3F
0CCE:  BCF    03.6
0CCF:  CALL   13B
....................       input_data++; 
0CD0:  MOVLW  02
0CD1:  BSF    03.6
0CD2:  ADDWF  37,F
0CD3:  BTFSC  03.0
0CD4:  INCF   38,F
....................    } 
0CD5:  MOVLW  02
0CD6:  ADDWF  39,F
0CD7:  GOTO   4A8
....................  
....................    modbus_serial_send_stop(); 
0CD8:  BCF    03.6
0CD9:  CALL   16A
0CDA:  NOP
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address,  
....................                                     unsigned int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
*
0C03:  MOVF   36,W
0C04:  MOVWF  3D
0C05:  MOVLW  05
0C06:  MOVWF  3E
0C07:  BCF    03.6
0C08:  CALL   154
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
0C09:  BSF    03.6
0C0A:  MOVF   38,W
0C0B:  MOVWF  3B
0C0C:  MOVWF  3F
0C0D:  BCF    03.6
0C0E:  CALL   13B
....................    modbus_serial_putc(make8(output_address,0)); 
0C0F:  BSF    03.6
0C10:  MOVF   37,W
0C11:  MOVWF  3B
0C12:  MOVWF  3F
0C13:  BCF    03.6
0C14:  CALL   13B
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
0C15:  BSF    03.6
0C16:  MOVF   3A,W
0C17:  MOVWF  3B
0C18:  MOVWF  3F
0C19:  BCF    03.6
0C1A:  CALL   13B
....................    modbus_serial_putc(make8(output_value,0)); 
0C1B:  BSF    03.6
0C1C:  MOVF   39,W
0C1D:  MOVWF  3B
0C1E:  MOVWF  3F
0C1F:  BCF    03.6
0C20:  CALL   13B
....................  
....................    modbus_serial_send_stop(); 
0C21:  CALL   16A
0C22:  NOP
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address,  
....................                                         unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status,  
....................                                         unsigned int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count,  
....................                                     unsigned int8 *events, unsigned int8 events_len) 
.................... { 
....................    unsigned int8 i; 
....................      
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address,  
....................                                         unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address,  
....................                                             unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
*
0DAA:  MOVF   38,W
0DAB:  MOVWF  3D
0DAC:  MOVLW  10
0DAD:  MOVWF  3E
0DAE:  BCF    03.6
0DAF:  CALL   154
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0DB0:  BSF    03.6
0DB1:  MOVF   3A,W
0DB2:  MOVWF  3D
0DB3:  MOVWF  3F
0DB4:  BCF    03.6
0DB5:  CALL   13B
....................    modbus_serial_putc(make8(start_address,0)); 
0DB6:  BSF    03.6
0DB7:  MOVF   39,W
0DB8:  MOVWF  3D
0DB9:  MOVWF  3F
0DBA:  BCF    03.6
0DBB:  CALL   13B
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0DBC:  BSF    03.6
0DBD:  MOVF   3C,W
0DBE:  MOVWF  3D
0DBF:  MOVWF  3F
0DC0:  BCF    03.6
0DC1:  CALL   13B
....................    modbus_serial_putc(make8(quantity,0)); 
0DC2:  BSF    03.6
0DC3:  MOVF   3B,W
0DC4:  MOVWF  3D
0DC5:  MOVWF  3F
0DC6:  BCF    03.6
0DC7:  CALL   13B
....................  
....................    modbus_serial_send_stop(); 
0DC8:  CALL   16A
0DC9:  NOP
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,  
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count,  
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len,  
....................                                                 unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
0DD7:  MOVF   35,W
0DD8:  IORLW  80
0DD9:  MOVWF  38
0DDA:  MOVF   36,W
0DDB:  MOVWF  39
0DDC:  MOVF   34,W
0DDD:  MOVWF  3D
0DDE:  MOVF   38,W
0DDF:  MOVWF  3E
0DE0:  BCF    03.6
0DE1:  CALL   154
....................    modbus_serial_putc(error); 
0DE2:  BSF    03.6
0DE3:  MOVF   37,W
0DE4:  MOVWF  3F
0DE5:  BCF    03.6
0DE6:  CALL   13B
....................    modbus_serial_send_stop(); 
0DE7:  CALL   16A
0DE8:  NOP
0DE9:  BSF    03.5
.................... } 
....................  
.................... #endif 
....................  
.................... #include <EEPROMmemory.c> 
.................... #ifndef use_external_memory 
....................    #define write_white_memory(address, data) write_eeprom(address, data) 
....................    #define read_white_memory(address) read_eeprom(address) 
....................    #define write_regist_memory(address, data) write_eeprom(address + 0x80, data) 
....................    #define read_regist_memory(address, data) read_eeprom(address + 0x80) 
.................... #else 
....................    #include i2c_memory.c 
....................    #define write_white_memory(address, data) write_ext_eeprom(address, data, 0) 
....................    #define read_white_memory(address) read_ext_eeprom(address, 0) 
....................    #define write_regist_memory(address, data) write_eeprom(address, data) 
....................    #define read_regist_memory(address, data) read_eeprom(address) 
.................... #endif 
....................  
....................  
....................  
.................... /*void write_access_memory(long int address, byte data) 
.................... {   
....................    write_ext_eeprom(address, data, 0); 
.................... } 
....................    
.................... BYTE read_access_memory(long int address) 
.................... {   
....................    return read_ext_eeprom(address, 0); 
.................... } 
....................  
.................... void write_regist_memory(long int address, byte data) 
.................... {   
....................    write_eeprom(address, data); 
.................... } 
....................    
.................... BYTE read_regist_memory(long int address) 
.................... {   
....................    return read_eeprom(address); 
.................... } 
....................  
....................  
....................  
....................  
.................... void write_access_memory(long int address, byte data) 
.................... {   
....................    write_eeprom(address, data); 
.................... } 
....................    
.................... BYTE read_access_memory(long int address) 
.................... {   
....................    return read_eeprom(address); 
.................... } 
....................  
.................... void write_regist_memory(long int address, byte data) 
.................... {   
....................    write_eeprom(address + 0x80, data); 
.................... } 
....................    
.................... BYTE read_regist_memory(long int address) 
.................... {   
....................    return read_eeprom(address + 0x80); 
.................... }*/ 
....................  
....................  
....................  
.................... #include <rtcDS1307.c> 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                      rtc.c                                       //// 
.................... ////                                                                                  //// 
.................... ////                    Driver para reloj de tiempo real por I2C                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  Funciones:                                                                      //// 
.................... ////                                                                                  //// 
.................... ////  real_time(minutes, hours, day, date, month, year)                               //// 
.................... ////    - Devuelve los datos de tiempo real en las variables pasadas como argumentos  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef use_emulated_rtc 
....................  
.................... #use i2c(master,sda=pin_c4,scl=pin_c3) 
*
033E:  MOVLW  08
033F:  MOVWF  78
0340:  NOP
0341:  BCF    07.3
0342:  BCF    55.3
0343:  MOVF   55,W
0344:  BSF    03.5
0345:  MOVWF  07
0346:  NOP
0347:  BCF    03.5
0348:  BSF    03.6
0349:  RLF    48,F
034A:  BCF    03.6
034B:  BCF    07.4
034C:  BTFSS  03.0
034D:  GOTO   354
034E:  BSF    55.4
034F:  MOVF   55,W
0350:  BSF    03.5
0351:  MOVWF  07
0352:  GOTO   358
0353:  BCF    03.5
0354:  BCF    55.4
0355:  MOVF   55,W
0356:  BSF    03.5
0357:  MOVWF  07
0358:  NOP
0359:  BCF    03.5
035A:  BSF    55.3
035B:  MOVF   55,W
035C:  BSF    03.5
035D:  MOVWF  07
035E:  BCF    03.5
035F:  BTFSS  07.3
0360:  GOTO   35F
0361:  DECFSZ 78,F
0362:  GOTO   340
0363:  NOP
0364:  BCF    07.3
0365:  BCF    55.3
0366:  MOVF   55,W
0367:  BSF    03.5
0368:  MOVWF  07
0369:  NOP
036A:  BCF    03.5
036B:  BSF    55.4
036C:  MOVF   55,W
036D:  BSF    03.5
036E:  MOVWF  07
036F:  NOP
0370:  NOP
0371:  BCF    03.5
0372:  BSF    55.3
0373:  MOVF   55,W
0374:  BSF    03.5
0375:  MOVWF  07
0376:  BCF    03.5
0377:  BTFSS  07.3
0378:  GOTO   377
0379:  CLRF   78
037A:  NOP
037B:  BTFSC  07.4
037C:  BSF    78.0
037D:  BCF    07.3
037E:  BCF    55.3
037F:  MOVF   55,W
0380:  BSF    03.5
0381:  MOVWF  07
0382:  BCF    03.5
0383:  BCF    07.4
0384:  BCF    55.4
0385:  MOVF   55,W
0386:  BSF    03.5
0387:  MOVWF  07
0388:  BCF    03.5
0389:  RETURN
038A:  MOVLW  08
038B:  BSF    03.6
038C:  MOVWF  49
038D:  MOVF   77,W
038E:  MOVWF  4A
038F:  BCF    03.6
0390:  BSF    55.4
0391:  MOVF   55,W
0392:  BSF    03.5
0393:  MOVWF  07
0394:  NOP
0395:  BCF    03.5
0396:  BSF    55.3
0397:  MOVF   55,W
0398:  BSF    03.5
0399:  MOVWF  07
039A:  BCF    03.5
039B:  BTFSS  07.3
039C:  GOTO   39B
039D:  BTFSC  07.4
039E:  BSF    03.0
039F:  BTFSS  07.4
03A0:  BCF    03.0
03A1:  RLF    78,F
03A2:  NOP
03A3:  BCF    55.3
03A4:  MOVF   55,W
03A5:  BSF    03.5
03A6:  MOVWF  07
03A7:  BCF    03.5
03A8:  BCF    07.3
03A9:  BSF    03.6
03AA:  DECFSZ 49,F
03AB:  GOTO   38F
03AC:  BCF    03.6
03AD:  BSF    55.4
03AE:  MOVF   55,W
03AF:  BSF    03.5
03B0:  MOVWF  07
03B1:  NOP
03B2:  BCF    03.5
03B3:  BCF    07.4
03B4:  BSF    03.6
03B5:  MOVF   4A,W
03B6:  BTFSC  03.2
03B7:  GOTO   3BF
03B8:  BCF    03.6
03B9:  BCF    55.4
03BA:  MOVF   55,W
03BB:  BSF    03.5
03BC:  MOVWF  07
03BD:  BCF    03.5
03BE:  BSF    03.6
03BF:  NOP
03C0:  BCF    03.6
03C1:  BSF    55.3
03C2:  MOVF   55,W
03C3:  BSF    03.5
03C4:  MOVWF  07
03C5:  BCF    03.5
03C6:  BTFSS  07.3
03C7:  GOTO   3C6
03C8:  NOP
03C9:  BCF    07.3
03CA:  BCF    55.3
03CB:  MOVF   55,W
03CC:  BSF    03.5
03CD:  MOVWF  07
03CE:  NOP
03CF:  BCF    03.5
03D0:  BCF    07.4
03D1:  BCF    55.4
03D2:  MOVF   55,W
03D3:  BSF    03.5
03D4:  MOVWF  07
03D5:  BCF    03.5
03D6:  RETURN
....................  
.................... int dec_to_bcd(int dec)  
.................... { 
....................    return (((dec/10)<<4) + dec%10); 
*
07BE:  BSF    03.6
07BF:  MOVF   39,W
07C0:  MOVWF  3B
07C1:  MOVLW  0A
07C2:  MOVWF  3C
07C3:  BCF    03.6
07C4:  CALL   7A7
07C5:  SWAPF  78,W
07C6:  BSF    03.6
07C7:  MOVWF  3A
07C8:  MOVLW  F0
07C9:  ANDWF  3A,F
07CA:  MOVF   39,W
07CB:  MOVWF  3B
07CC:  MOVLW  0A
07CD:  MOVWF  3C
07CE:  BCF    03.6
07CF:  CALL   7A7
07D0:  MOVF   77,W
07D1:  BSF    03.6
07D2:  ADDWF  3A,W
07D3:  MOVWF  78
.................... } 
07D4:  BCF    03.6
07D5:  RETURN
....................  
.................... int bcd_to_dec(int bcd) 
.................... { 
....................    int varia; 
....................    varia = bcd; 
*
03D7:  BSF    03.6
03D8:  MOVF   49,W
03D9:  MOVWF  4A
....................    varia >>= 1; 
03DA:  BCF    03.0
03DB:  RRF    4A,F
....................    varia &= 0x78; 
03DC:  MOVLW  78
03DD:  ANDWF  4A,F
....................    return(varia + (varia >> 2) + (bcd & 0x0f)); 
03DE:  RRF    4A,W
03DF:  MOVWF  77
03E0:  RRF    77,F
03E1:  MOVLW  3F
03E2:  ANDWF  77,F
03E3:  MOVF   77,W
03E4:  ADDWF  4A,W
03E5:  MOVWF  4B
03E6:  MOVF   49,W
03E7:  ANDLW  0F
03E8:  ADDWF  4B,W
03E9:  MOVWF  78
.................... } 
03EA:  BCF    03.6
03EB:  RETURN
....................  
.................... void rtc_init(int minutes, int hours, int date, int month, int year) 
.................... { 
....................    i2c_start();      //Escritura 
*
0800:  BSF    55.4
0801:  MOVF   55,W
0802:  BSF    03.5
0803:  MOVWF  07
0804:  NOP
0805:  BCF    03.5
0806:  BSF    55.3
0807:  MOVF   55,W
0808:  BSF    03.5
0809:  MOVWF  07
080A:  NOP
080B:  BCF    03.5
080C:  BCF    07.4
080D:  BCF    55.4
080E:  MOVF   55,W
080F:  BSF    03.5
0810:  MOVWF  07
0811:  NOP
0812:  BCF    03.5
0813:  BCF    07.3
0814:  BCF    55.3
0815:  MOVF   55,W
0816:  BSF    03.5
0817:  MOVWF  07
0818:  BCF    03.5
0819:  CLRF   27
081A:  BTFSC  0B.7
081B:  BSF    27.7
081C:  BCF    0B.7
....................    i2c_write(0xD0);   //Codigo de escritura 
081D:  MOVLW  D0
081E:  BSF    03.6
081F:  MOVWF  48
0820:  BCF    0A.3
0821:  BCF    03.6
0822:  CALL   33E
0823:  BSF    0A.3
0824:  BTFSC  27.7
0825:  BSF    0B.7
0826:  CLRF   27
0827:  BTFSC  0B.7
0828:  BSF    27.7
0829:  BCF    0B.7
....................    i2c_write(0x00);   //Puntero a la primera direccion(segundos) 
082A:  BSF    03.6
082B:  CLRF   48
082C:  BCF    0A.3
082D:  BCF    03.6
082E:  CALL   33E
082F:  BSF    0A.3
0830:  BTFSC  27.7
0831:  BSF    0B.7
0832:  CLRF   27
0833:  BTFSC  0B.7
0834:  BSF    27.7
0835:  BCF    0B.7
....................  
....................    /*i2c_start();      //escritura 
....................    i2c_write(0xD0);   //Codigo de escritura*/ 
....................    i2c_write(0);  
0836:  BSF    03.6
0837:  CLRF   48
0838:  BCF    0A.3
0839:  BCF    03.6
083A:  CALL   33E
083B:  BSF    0A.3
083C:  BTFSC  27.7
083D:  BSF    0B.7
....................    i2c_write(dec_to_bcd(minutes));    
083E:  BSF    03.6
083F:  MOVF   34,W
0840:  MOVWF  39
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   7BE
0844:  BSF    0A.3
0845:  MOVF   78,W
0846:  BSF    03.6
0847:  MOVWF  39
0848:  BCF    03.6
0849:  CLRF   27
084A:  BTFSC  0B.7
084B:  BSF    27.7
084C:  BCF    0B.7
084D:  BSF    03.6
084E:  MOVF   39,W
084F:  MOVWF  48
0850:  BCF    0A.3
0851:  BCF    03.6
0852:  CALL   33E
0853:  BSF    0A.3
0854:  BTFSC  27.7
0855:  BSF    0B.7
....................    i2c_write(dec_to_bcd(hours));    
0856:  BSF    03.6
0857:  MOVF   35,W
0858:  MOVWF  39
0859:  BCF    0A.3
085A:  BCF    03.6
085B:  CALL   7BE
085C:  BSF    0A.3
085D:  MOVF   78,W
085E:  BSF    03.6
085F:  MOVWF  39
0860:  BCF    03.6
0861:  CLRF   27
0862:  BTFSC  0B.7
0863:  BSF    27.7
0864:  BCF    0B.7
0865:  BSF    03.6
0866:  MOVF   39,W
0867:  MOVWF  48
0868:  BCF    0A.3
0869:  BCF    03.6
086A:  CALL   33E
086B:  BSF    0A.3
086C:  BTFSC  27.7
086D:  BSF    0B.7
086E:  CLRF   27
086F:  BTFSC  0B.7
0870:  BSF    27.7
0871:  BCF    0B.7
....................    i2c_write(2);    
0872:  MOVLW  02
0873:  BSF    03.6
0874:  MOVWF  48
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   33E
0878:  BSF    0A.3
0879:  BTFSC  27.7
087A:  BSF    0B.7
....................    i2c_write(dec_to_bcd(date));    
087B:  BSF    03.6
087C:  MOVF   36,W
087D:  MOVWF  39
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   7BE
0881:  BSF    0A.3
0882:  MOVF   78,W
0883:  BSF    03.6
0884:  MOVWF  39
0885:  BCF    03.6
0886:  CLRF   27
0887:  BTFSC  0B.7
0888:  BSF    27.7
0889:  BCF    0B.7
088A:  BSF    03.6
088B:  MOVF   39,W
088C:  MOVWF  48
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   33E
0890:  BSF    0A.3
0891:  BTFSC  27.7
0892:  BSF    0B.7
....................    i2c_write(dec_to_bcd(month));    
0893:  BSF    03.6
0894:  MOVF   37,W
0895:  MOVWF  39
0896:  BCF    0A.3
0897:  BCF    03.6
0898:  CALL   7BE
0899:  BSF    0A.3
089A:  MOVF   78,W
089B:  BSF    03.6
089C:  MOVWF  39
089D:  BCF    03.6
089E:  CLRF   27
089F:  BTFSC  0B.7
08A0:  BSF    27.7
08A1:  BCF    0B.7
08A2:  BSF    03.6
08A3:  MOVF   39,W
08A4:  MOVWF  48
08A5:  BCF    0A.3
08A6:  BCF    03.6
08A7:  CALL   33E
08A8:  BSF    0A.3
08A9:  BTFSC  27.7
08AA:  BSF    0B.7
....................    i2c_write(dec_to_bcd(year));    
08AB:  BSF    03.6
08AC:  MOVF   38,W
08AD:  MOVWF  39
08AE:  BCF    0A.3
08AF:  BCF    03.6
08B0:  CALL   7BE
08B1:  BSF    0A.3
08B2:  MOVF   78,W
08B3:  BSF    03.6
08B4:  MOVWF  39
08B5:  BCF    03.6
08B6:  CLRF   27
08B7:  BTFSC  0B.7
08B8:  BSF    27.7
08B9:  BCF    0B.7
08BA:  BSF    03.6
08BB:  MOVF   39,W
08BC:  MOVWF  48
08BD:  BCF    0A.3
08BE:  BCF    03.6
08BF:  CALL   33E
08C0:  BSF    0A.3
08C1:  BTFSC  27.7
08C2:  BSF    0B.7
....................    i2c_stop(); 
08C3:  BCF    55.4
08C4:  MOVF   55,W
08C5:  BSF    03.5
08C6:  MOVWF  07
08C7:  NOP
08C8:  BCF    03.5
08C9:  BSF    55.3
08CA:  MOVF   55,W
08CB:  BSF    03.5
08CC:  MOVWF  07
08CD:  BCF    03.5
08CE:  BTFSS  07.3
08CF:  GOTO   0CE
08D0:  NOP
08D1:  GOTO   0D2
08D2:  NOP
08D3:  BSF    55.4
08D4:  MOVF   55,W
08D5:  BSF    03.5
08D6:  MOVWF  07
08D7:  NOP
.................... } 
08D8:  BCF    03.5
08D9:  RETURN
....................  
.................... void real_time(int &minutes, int &hours, int &date, int &month, int &year) 
.................... //void real_time() 
.................... { 
....................    //int seconds; 
....................    int day; 
....................    i2c_start();      //Escritura 
*
03EC:  BSF    55.4
03ED:  MOVF   55,W
03EE:  BSF    03.5
03EF:  MOVWF  07
03F0:  NOP
03F1:  BCF    03.5
03F2:  BSF    55.3
03F3:  MOVF   55,W
03F4:  BSF    03.5
03F5:  MOVWF  07
03F6:  NOP
03F7:  BCF    03.5
03F8:  BCF    07.4
03F9:  BCF    55.4
03FA:  MOVF   55,W
03FB:  BSF    03.5
03FC:  MOVWF  07
03FD:  NOP
03FE:  BCF    03.5
03FF:  BCF    07.3
0400:  BCF    55.3
0401:  MOVF   55,W
0402:  BSF    03.5
0403:  MOVWF  07
*
05DA:  BSF    55.4
05DB:  MOVF   55,W
05DC:  BSF    03.5
05DD:  MOVWF  07
05DE:  NOP
05DF:  BCF    03.5
05E0:  BSF    55.3
05E1:  MOVF   55,W
05E2:  BSF    03.5
05E3:  MOVWF  07
05E4:  NOP
05E5:  BCF    03.5
05E6:  BCF    07.4
05E7:  BCF    55.4
05E8:  MOVF   55,W
05E9:  BSF    03.5
05EA:  MOVWF  07
05EB:  NOP
05EC:  BCF    03.5
05ED:  BCF    07.3
05EE:  BCF    55.3
05EF:  MOVF   55,W
05F0:  BSF    03.5
05F1:  MOVWF  07
....................    i2c_write(0xD0);   //Codigo de escritura 
*
0404:  MOVLW  D0
0405:  BCF    03.5
0406:  BSF    03.6
0407:  MOVWF  48
0408:  BCF    03.6
0409:  CALL   33E
*
05F2:  MOVLW  D0
05F3:  BCF    03.5
05F4:  BSF    03.6
05F5:  MOVWF  48
05F6:  BCF    03.6
05F7:  CALL   33E
....................    //i2c_write(0x00);   //Puntero a la primera direccion(segundos) 
....................    i2c_write(0x01);   //Puntero a la segunda direccion(minutos) 
*
040A:  MOVLW  01
040B:  BSF    03.6
040C:  MOVWF  48
040D:  BCF    03.6
040E:  CALL   33E
*
05F8:  MOVLW  01
05F9:  BSF    03.6
05FA:  MOVWF  48
05FB:  BCF    03.6
05FC:  CALL   33E
....................  
....................    i2c_start();      //Lectura 
*
040F:  BSF    55.4
0410:  MOVF   55,W
0411:  BSF    03.5
0412:  MOVWF  07
0413:  NOP
0414:  BCF    03.5
0415:  BSF    55.3
0416:  MOVF   55,W
0417:  BSF    03.5
0418:  MOVWF  07
0419:  NOP
041A:  BCF    03.5
041B:  BTFSS  07.3
041C:  GOTO   41B
041D:  BCF    07.4
041E:  BCF    55.4
041F:  MOVF   55,W
0420:  BSF    03.5
0421:  MOVWF  07
0422:  NOP
0423:  BCF    03.5
0424:  BCF    07.3
0425:  BCF    55.3
0426:  MOVF   55,W
0427:  BSF    03.5
0428:  MOVWF  07
*
05FD:  BSF    55.4
05FE:  MOVF   55,W
05FF:  BSF    03.5
0600:  MOVWF  07
0601:  NOP
0602:  BCF    03.5
0603:  BSF    55.3
0604:  MOVF   55,W
0605:  BSF    03.5
0606:  MOVWF  07
0607:  NOP
0608:  BCF    03.5
0609:  BTFSS  07.3
060A:  GOTO   609
060B:  BCF    07.4
060C:  BCF    55.4
060D:  MOVF   55,W
060E:  BSF    03.5
060F:  MOVWF  07
0610:  NOP
0611:  BCF    03.5
0612:  BCF    07.3
0613:  BCF    55.3
0614:  MOVF   55,W
0615:  BSF    03.5
0616:  MOVWF  07
....................    i2c_write(0xD1);   //Codigo de lectura 
*
0429:  MOVLW  D1
042A:  BCF    03.5
042B:  BSF    03.6
042C:  MOVWF  48
042D:  BCF    03.6
042E:  CALL   33E
*
0617:  MOVLW  D1
0618:  BCF    03.5
0619:  BSF    03.6
061A:  MOVWF  48
061B:  BCF    03.6
061C:  CALL   33E
....................    //seconds = bcd_to_dec(i2c_read() & 0x7f);   //Lectura de los 7 bit de los segundos 
....................    minutes = bcd_to_dec(i2c_read() & 0x7f);   //Lectura de los 7 bit de los minutos 
*
042F:  MOVLW  01
0430:  MOVWF  77
0431:  CALL   38A
0432:  MOVF   78,W
0433:  ANDLW  7F
0434:  BSF    03.6
0435:  MOVWF  43
0436:  MOVWF  49
0437:  BCF    03.6
0438:  CALL   3D7
0439:  MOVF   78,W
043A:  MOVWF  29
*
061D:  MOVLW  01
061E:  MOVWF  77
061F:  CALL   38A
0620:  MOVF   78,W
0621:  ANDLW  7F
0622:  BSF    03.6
0623:  MOVWF  43
0624:  MOVWF  49
0625:  BCF    03.6
0626:  CALL   3D7
0627:  MOVF   78,W
0628:  MOVWF  29
....................    hours = bcd_to_dec(i2c_read() & 0x3f);   //Lectura de los 6 bit de las horas 
*
043B:  MOVLW  01
043C:  MOVWF  77
043D:  CALL   38A
043E:  MOVF   78,W
043F:  ANDLW  3F
0440:  BSF    03.6
0441:  MOVWF  43
0442:  MOVWF  49
0443:  BCF    03.6
0444:  CALL   3D7
0445:  MOVF   78,W
0446:  MOVWF  2A
*
0629:  MOVLW  01
062A:  MOVWF  77
062B:  CALL   38A
062C:  MOVF   78,W
062D:  ANDLW  3F
062E:  BSF    03.6
062F:  MOVWF  43
0630:  MOVWF  49
0631:  BCF    03.6
0632:  CALL   3D7
0633:  MOVF   78,W
0634:  MOVWF  2A
....................    day = bcd_to_dec(i2c_read() & 0x07);   //Lectura de los 3 bit del dia de la semana 
*
0447:  MOVLW  01
0448:  MOVWF  77
0449:  CALL   38A
044A:  MOVF   78,W
044B:  ANDLW  07
044C:  BSF    03.6
044D:  MOVWF  43
044E:  MOVWF  49
044F:  BCF    03.6
0450:  CALL   3D7
0451:  MOVF   78,W
0452:  BSF    03.6
0453:  MOVWF  42
*
0635:  MOVLW  01
0636:  MOVWF  77
0637:  CALL   38A
0638:  MOVF   78,W
0639:  ANDLW  07
063A:  BSF    03.6
063B:  MOVWF  43
063C:  MOVWF  49
063D:  BCF    03.6
063E:  CALL   3D7
063F:  MOVF   78,W
0640:  BSF    03.6
0641:  MOVWF  42
....................    date = bcd_to_dec(i2c_read() & 0x3f);   //Lectura de los 6 bit del dia del mes 
*
0454:  MOVLW  01
0455:  MOVWF  77
0456:  BCF    03.6
0457:  CALL   38A
0458:  MOVF   78,W
0459:  ANDLW  3F
045A:  BSF    03.6
045B:  MOVWF  43
045C:  MOVWF  49
045D:  BCF    03.6
045E:  CALL   3D7
045F:  MOVF   78,W
0460:  MOVWF  2B
*
0642:  MOVLW  01
0643:  MOVWF  77
0644:  BCF    03.6
0645:  CALL   38A
0646:  MOVF   78,W
0647:  ANDLW  3F
0648:  BSF    03.6
0649:  MOVWF  43
064A:  MOVWF  49
064B:  BCF    03.6
064C:  CALL   3D7
064D:  MOVF   78,W
064E:  MOVWF  2B
....................    month = bcd_to_dec(i2c_read() & 0x1f);   //Lectura de los 5 bit del mes 
*
0461:  MOVLW  01
0462:  MOVWF  77
0463:  CALL   38A
0464:  MOVF   78,W
0465:  ANDLW  1F
0466:  BSF    03.6
0467:  MOVWF  43
0468:  MOVWF  49
0469:  BCF    03.6
046A:  CALL   3D7
046B:  MOVF   78,W
046C:  MOVWF  2C
*
064F:  MOVLW  01
0650:  MOVWF  77
0651:  CALL   38A
0652:  MOVF   78,W
0653:  ANDLW  1F
0654:  BSF    03.6
0655:  MOVWF  43
0656:  MOVWF  49
0657:  BCF    03.6
0658:  CALL   3D7
0659:  MOVF   78,W
065A:  MOVWF  2C
....................    year = bcd_to_dec(i2c_read());   //Lectura de los 8 bit del ao 
*
046D:  MOVLW  01
046E:  MOVWF  77
046F:  CALL   38A
0470:  MOVF   78,W
0471:  BSF    03.6
0472:  MOVWF  43
0473:  MOVWF  49
0474:  BCF    03.6
0475:  CALL   3D7
0476:  MOVF   78,W
0477:  MOVWF  2E
*
065B:  MOVLW  01
065C:  MOVWF  77
065D:  CALL   38A
065E:  MOVF   78,W
065F:  BSF    03.6
0660:  MOVWF  43
0661:  MOVWF  49
0662:  BCF    03.6
0663:  CALL   3D7
0664:  MOVF   78,W
0665:  MOVWF  2E
....................  
....................    i2c_stop(); 
*
0478:  BCF    55.4
0479:  MOVF   55,W
047A:  BSF    03.5
047B:  MOVWF  07
047C:  NOP
047D:  BCF    03.5
047E:  BSF    55.3
047F:  MOVF   55,W
0480:  BSF    03.5
0481:  MOVWF  07
0482:  BCF    03.5
0483:  BTFSS  07.3
0484:  GOTO   483
0485:  NOP
0486:  GOTO   487
0487:  NOP
0488:  BSF    55.4
0489:  MOVF   55,W
048A:  BSF    03.5
048B:  MOVWF  07
048C:  NOP
*
0666:  BCF    55.4
0667:  MOVF   55,W
0668:  BSF    03.5
0669:  MOVWF  07
066A:  NOP
066B:  BCF    03.5
066C:  BSF    55.3
066D:  MOVF   55,W
066E:  BSF    03.5
066F:  MOVWF  07
0670:  BCF    03.5
0671:  BTFSS  07.3
0672:  GOTO   671
0673:  NOP
0674:  GOTO   675
0675:  NOP
0676:  BSF    55.4
0677:  MOVF   55,W
0678:  BSF    03.5
0679:  MOVWF  07
067A:  NOP
.................... } 
....................       
.................... #else 
....................  
.................... int r_minutes;  
.................... int r_hours;  
.................... int r_date;  
.................... int r_month;  
.................... int r_year; 
....................  
.................... void rtc_init(int minutes, int hours, int date, int month, int year) 
.................... { 
....................    r_minutes = minutes;  
....................    r_hours = hours;  
....................    r_date = date;  
....................    r_month = month;  
....................    r_year = year; 
.................... } 
....................     
.................... void real_time(int &minutes, int &hours, int &date, int &month, int &year) 
.................... { 
....................    r_minutes++; 
....................    if(minutes == 60){ 
....................       r_hours++;  
....................       r_minutes = 0; 
....................    r_date = date;  
....................    r_month = month;  
....................    r_year = year; 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... //#include <LCD2.c> 
....................  
.................... EEPROM_ADDRESS address = 0; 
.................... EEPROM_ADDRESS access_address = 2;   //direccion corriente de la memoria de accesos 
.................... BYTE access_event_count = 0; 
.................... int16 mbus_data[16]; 
....................  
.................... //Funcion que obtiene la direccion en la red del controlador seteada a traves de jumpers 
.................... int get_modbus_address() 
.................... { 
.................... 	int temp = input_a(); 
.................... 	temp &= 0b00001111; 
.................... 	return temp; 
.................... } 
....................  
.................... //Funcion que crea la data que hay que pasar como respuesta al master 
.................... void regist_data(int index, int offset) 
.................... { 
....................    int high, low, i; 
....................    for(i = 0; i < offset; i++){ 
*
09B2:  BSF    03.6
09B3:  CLRF   38
09B4:  MOVF   35,W
09B5:  SUBWF  38,W
09B6:  BTFSC  03.0
09B7:  GOTO   1DD
....................       high = read_regist_memory(index); 
09B8:  MOVLW  80
09B9:  ADDWF  34,W
09BA:  MOVWF  39
09BB:  MOVF   39,W
09BC:  MOVWF  0D
09BD:  BSF    03.5
09BE:  BCF    0C.7
09BF:  BSF    0C.0
09C0:  BCF    03.5
09C1:  MOVF   0C,W
09C2:  MOVWF  36
....................       index++; 
09C3:  INCF   34,F
....................       low = read_regist_memory(index); 
09C4:  MOVLW  80
09C5:  ADDWF  34,W
09C6:  MOVWF  39
09C7:  MOVF   39,W
09C8:  MOVWF  0D
09C9:  BSF    03.5
09CA:  BCF    0C.7
09CB:  BSF    0C.0
09CC:  BCF    03.5
09CD:  MOVF   0C,W
09CE:  MOVWF  37
....................       index++; 
09CF:  INCF   34,F
....................       mbus_data[i] = make16(high, low); 
09D0:  BCF    03.0
09D1:  RLF    38,W
09D2:  ADDLW  10
09D3:  MOVWF  04
09D4:  BSF    03.7
09D5:  INCF   04,F
09D6:  MOVF   36,W
09D7:  MOVWF  00
09D8:  DECF   04,F
09D9:  MOVF   37,W
09DA:  MOVWF  00
....................    } 
09DB:  INCF   38,F
09DC:  GOTO   1B4
.................... } 
09DD:  BCF    03.6
09DE:  BSF    0A.3
09DF:  BCF    0A.4
09E0:  GOTO   48D (RETURN)
....................  
.................... //Funcion que crea la data que hay que pasar como respuesta al master 
.................... void conf_data(int index, int offset) 
.................... { 
....................    int high, low, i; 
....................    for(i = 0; i < offset; i++){ 
*
0989:  BSF    03.6
098A:  CLRF   38
098B:  MOVF   35,W
098C:  SUBWF  38,W
098D:  BTFSC  03.0
098E:  GOTO   1AE
....................       high = read_white_memory(index); 
098F:  MOVF   34,W
0990:  MOVWF  0D
0991:  BSF    03.5
0992:  BCF    0C.7
0993:  BSF    0C.0
0994:  BCF    03.5
0995:  MOVF   0C,W
0996:  MOVWF  36
....................       index++; 
0997:  INCF   34,F
....................       low = read_white_memory(index); 
0998:  MOVF   34,W
0999:  MOVWF  0D
099A:  BSF    03.5
099B:  BCF    0C.7
099C:  BSF    0C.0
099D:  BCF    03.5
099E:  MOVF   0C,W
099F:  MOVWF  37
....................       index++; 
09A0:  INCF   34,F
....................       mbus_data[i] = make16(high, low); 
09A1:  BCF    03.0
09A2:  RLF    38,W
09A3:  ADDLW  10
09A4:  MOVWF  04
09A5:  BSF    03.7
09A6:  INCF   04,F
09A7:  MOVF   36,W
09A8:  MOVWF  00
09A9:  DECF   04,F
09AA:  MOVF   37,W
09AB:  MOVWF  00
....................    } 
09AC:  INCF   38,F
09AD:  GOTO   18B
.................... } 
09AE:  BCF    03.6
09AF:  BSF    0A.3
09B0:  BCF    0A.4
09B1:  GOTO   431 (RETURN)
....................  
.................... //Funcion que limpia los registros 
.................... void clean_registers() 
.................... { 
.................... 	write_regist_memory(0, 0); 
*
0738:  MOVLW  80
0739:  BSF    03.6
073A:  MOVWF  0D
073B:  CLRF   0C
073C:  BSF    03.5
073D:  BCF    0C.7
073E:  BSF    0C.2
073F:  BCF    03.5
0740:  BCF    03.6
0741:  MOVF   0B,W
0742:  MOVWF  77
0743:  BCF    0B.7
0744:  BSF    03.5
0745:  BSF    03.6
0746:  MOVLW  55
0747:  MOVWF  0D
0748:  MOVLW  AA
0749:  MOVWF  0D
074A:  BSF    0C.1
074B:  BTFSC  0C.1
074C:  GOTO   74B
074D:  BCF    0C.2
074E:  MOVF   77,W
074F:  BCF    03.5
0750:  BCF    03.6
0751:  IORWF  0B,F
.................... 	write_regist_memory(1, 0); 
0752:  MOVLW  81
0753:  BSF    03.6
0754:  MOVWF  0D
0755:  CLRF   0C
0756:  BSF    03.5
0757:  BCF    0C.7
0758:  BSF    0C.2
0759:  BCF    03.5
075A:  BCF    03.6
075B:  MOVF   0B,W
075C:  MOVWF  77
075D:  BCF    0B.7
075E:  BSF    03.5
075F:  BSF    03.6
0760:  MOVLW  55
0761:  MOVWF  0D
0762:  MOVLW  AA
0763:  MOVWF  0D
0764:  BSF    0C.1
0765:  BTFSC  0C.1
0766:  GOTO   765
0767:  BCF    0C.2
0768:  MOVF   77,W
0769:  BCF    03.5
076A:  BCF    03.6
076B:  IORWF  0B,F
.................... 	access_address = 2; 
076C:  CLRF   59
076D:  MOVLW  02
076E:  MOVWF  58
.................... 	access_event_count = 0; 
076F:  CLRF   5A
.................... } 
0770:  RETURN
....................  
.................... //Funcion que limpia los usuarios 
.................... void clean_white_memory() 
.................... { 
....................    write_white_memory(0, 0); 
0771:  BSF    03.6
0772:  CLRF   0D
0773:  CLRF   0C
0774:  BSF    03.5
0775:  BCF    0C.7
0776:  BSF    0C.2
0777:  BCF    03.5
0778:  BCF    03.6
0779:  MOVF   0B,W
077A:  MOVWF  77
077B:  BCF    0B.7
077C:  BSF    03.5
077D:  BSF    03.6
077E:  MOVLW  55
077F:  MOVWF  0D
0780:  MOVLW  AA
0781:  MOVWF  0D
0782:  BSF    0C.1
0783:  BTFSC  0C.1
0784:  GOTO   783
0785:  BCF    0C.2
0786:  MOVF   77,W
0787:  BCF    03.5
0788:  BCF    03.6
0789:  IORWF  0B,F
....................    write_white_memory(1, 0); 
078A:  MOVLW  01
078B:  BSF    03.6
078C:  MOVWF  0D
078D:  CLRF   0C
078E:  BSF    03.5
078F:  BCF    0C.7
0790:  BSF    0C.2
0791:  BCF    03.5
0792:  BCF    03.6
0793:  MOVF   0B,W
0794:  MOVWF  77
0795:  BCF    0B.7
0796:  BSF    03.5
0797:  BSF    03.6
0798:  MOVLW  55
0799:  MOVWF  0D
079A:  MOVLW  AA
079B:  MOVWF  0D
079C:  BSF    0C.1
079D:  BTFSC  0C.1
079E:  GOTO   79D
079F:  BCF    0C.2
07A0:  MOVF   77,W
07A1:  BCF    03.5
07A2:  BCF    03.6
07A3:  IORWF  0B,F
.................... } 
07A4:  BSF    0A.3
07A5:  BCF    0A.4
07A6:  GOTO   216 (RETURN)
....................  
.................... //Funcion que desbloquea la puerta por un tiempo 
.................... void handle_door() 
.................... { 
.................... 	if(current_door){   //Puerta 1 
*
06AD:  BTFSS  2F.0
06AE:  GOTO   6BC
....................       output_high(green_led_door_1); 
06AF:  BSF    03.5
06B0:  BCF    05.1
06B1:  BCF    03.5
06B2:  BSF    05.1
.................... 	  output_low(red_led_door_1); 
06B3:  BSF    03.5
06B4:  BCF    05.2
06B5:  BCF    03.5
06B6:  BCF    05.2
.................... 	  output_high(open_door_1); 
06B7:  BSF    03.5
06B8:  BCF    05.3
06B9:  BCF    03.5
06BA:  BSF    05.3
....................    } 
....................    else{ //Puerta 0 
06BB:  GOTO   6CA
....................       output_high(green_led_door_0); 
06BC:  BSF    03.5
06BD:  BCF    08.1
06BE:  BCF    03.5
06BF:  BSF    08.1
....................       output_low(red_led_door_0); 
06C0:  BSF    03.5
06C1:  BCF    08.2
06C2:  BCF    03.5
06C3:  BCF    08.2
....................       output_high(open_door_0); 
06C4:  BCF    55.5
06C5:  MOVF   55,W
06C6:  BSF    03.5
06C7:  MOVWF  07
06C8:  BCF    03.5
06C9:  BSF    07.5
....................    } 
....................    enable_interrupts(int_timer1); 
06CA:  BSF    03.5
06CB:  BSF    0C.0
....................    set_timer1(3036); 
06CC:  MOVLW  0B
06CD:  BCF    03.5
06CE:  MOVWF  0F
06CF:  MOVLW  DC
06D0:  MOVWF  0E
.................... } 
06D1:  RETURN
....................  
.................... //Acciones al producirse un acceso 
.................... void regist() 
.................... { 
....................    //Registrando el acceso 
....................    real_time(minutes, hours, date, mounth, year_low); 
....................  
....................    write_regist_memory(access_address, user); 
*
048D:  MOVLW  80
048E:  BCF    03.5
048F:  ADDWF  58,W
0490:  BSF    03.6
0491:  MOVWF  42
0492:  BCF    03.6
0493:  MOVF   59,W
0494:  BSF    03.6
0495:  MOVWF  43
0496:  BTFSC  03.0
0497:  INCF   43,F
0498:  MOVF   42,W
0499:  MOVWF  0D
049A:  BCF    03.6
049B:  MOVF   30,W
049C:  BSF    03.6
049D:  MOVWF  0C
049E:  BSF    03.5
049F:  BCF    0C.7
04A0:  BSF    0C.2
04A1:  BCF    03.5
04A2:  BCF    03.6
04A3:  MOVF   0B,W
04A4:  MOVWF  77
04A5:  BCF    0B.7
04A6:  BSF    03.5
04A7:  BSF    03.6
04A8:  MOVLW  55
04A9:  MOVWF  0D
04AA:  MOVLW  AA
04AB:  MOVWF  0D
04AC:  BSF    0C.1
04AD:  BTFSC  0C.1
04AE:  GOTO   4AD
04AF:  BCF    0C.2
04B0:  MOVF   77,W
04B1:  BCF    03.5
04B2:  BCF    03.6
04B3:  IORWF  0B,F
....................    access_address++; 
04B4:  INCF   58,F
04B5:  BTFSC  03.2
04B6:  INCF   59,F
....................    write_regist_memory(access_address, minutes); 
04B7:  MOVLW  80
04B8:  ADDWF  58,W
04B9:  BSF    03.6
04BA:  MOVWF  42
04BB:  BCF    03.6
04BC:  MOVF   59,W
04BD:  BSF    03.6
04BE:  MOVWF  43
04BF:  BTFSC  03.0
04C0:  INCF   43,F
04C1:  MOVF   42,W
04C2:  MOVWF  0D
04C3:  BCF    03.6
04C4:  MOVF   29,W
04C5:  BSF    03.6
04C6:  MOVWF  0C
04C7:  BSF    03.5
04C8:  BCF    0C.7
04C9:  BSF    0C.2
04CA:  BCF    03.5
04CB:  BCF    03.6
04CC:  MOVF   0B,W
04CD:  MOVWF  77
04CE:  BCF    0B.7
04CF:  BSF    03.5
04D0:  BSF    03.6
04D1:  MOVLW  55
04D2:  MOVWF  0D
04D3:  MOVLW  AA
04D4:  MOVWF  0D
04D5:  BSF    0C.1
04D6:  BTFSC  0C.1
04D7:  GOTO   4D6
04D8:  BCF    0C.2
04D9:  MOVF   77,W
04DA:  BCF    03.5
04DB:  BCF    03.6
04DC:  IORWF  0B,F
....................    access_address++; 
04DD:  INCF   58,F
04DE:  BTFSC  03.2
04DF:  INCF   59,F
....................    write_regist_memory(access_address, hours); 
04E0:  MOVLW  80
04E1:  ADDWF  58,W
04E2:  BSF    03.6
04E3:  MOVWF  42
04E4:  BCF    03.6
04E5:  MOVF   59,W
04E6:  BSF    03.6
04E7:  MOVWF  43
04E8:  BTFSC  03.0
04E9:  INCF   43,F
04EA:  MOVF   42,W
04EB:  MOVWF  0D
04EC:  BCF    03.6
04ED:  MOVF   2A,W
04EE:  BSF    03.6
04EF:  MOVWF  0C
04F0:  BSF    03.5
04F1:  BCF    0C.7
04F2:  BSF    0C.2
04F3:  BCF    03.5
04F4:  BCF    03.6
04F5:  MOVF   0B,W
04F6:  MOVWF  77
04F7:  BCF    0B.7
04F8:  BSF    03.5
04F9:  BSF    03.6
04FA:  MOVLW  55
04FB:  MOVWF  0D
04FC:  MOVLW  AA
04FD:  MOVWF  0D
04FE:  BSF    0C.1
04FF:  BTFSC  0C.1
0500:  GOTO   4FF
0501:  BCF    0C.2
0502:  MOVF   77,W
0503:  BCF    03.5
0504:  BCF    03.6
0505:  IORWF  0B,F
....................    access_address++; 
0506:  INCF   58,F
0507:  BTFSC  03.2
0508:  INCF   59,F
....................    write_regist_memory(access_address, date); 
0509:  MOVLW  80
050A:  ADDWF  58,W
050B:  BSF    03.6
050C:  MOVWF  42
050D:  BCF    03.6
050E:  MOVF   59,W
050F:  BSF    03.6
0510:  MOVWF  43
0511:  BTFSC  03.0
0512:  INCF   43,F
0513:  MOVF   42,W
0514:  MOVWF  0D
0515:  BCF    03.6
0516:  MOVF   2B,W
0517:  BSF    03.6
0518:  MOVWF  0C
0519:  BSF    03.5
051A:  BCF    0C.7
051B:  BSF    0C.2
051C:  BCF    03.5
051D:  BCF    03.6
051E:  MOVF   0B,W
051F:  MOVWF  77
0520:  BCF    0B.7
0521:  BSF    03.5
0522:  BSF    03.6
0523:  MOVLW  55
0524:  MOVWF  0D
0525:  MOVLW  AA
0526:  MOVWF  0D
0527:  BSF    0C.1
0528:  BTFSC  0C.1
0529:  GOTO   528
052A:  BCF    0C.2
052B:  MOVF   77,W
052C:  BCF    03.5
052D:  BCF    03.6
052E:  IORWF  0B,F
....................    access_address++; 
052F:  INCF   58,F
0530:  BTFSC  03.2
0531:  INCF   59,F
.................... 	write_regist_memory(access_address, mounth); 
0532:  MOVLW  80
0533:  ADDWF  58,W
0534:  BSF    03.6
0535:  MOVWF  42
0536:  BCF    03.6
0537:  MOVF   59,W
0538:  BSF    03.6
0539:  MOVWF  43
053A:  BTFSC  03.0
053B:  INCF   43,F
053C:  MOVF   42,W
053D:  MOVWF  0D
053E:  BCF    03.6
053F:  MOVF   2C,W
0540:  BSF    03.6
0541:  MOVWF  0C
0542:  BSF    03.5
0543:  BCF    0C.7
0544:  BSF    0C.2
0545:  BCF    03.5
0546:  BCF    03.6
0547:  MOVF   0B,W
0548:  MOVWF  77
0549:  BCF    0B.7
054A:  BSF    03.5
054B:  BSF    03.6
054C:  MOVLW  55
054D:  MOVWF  0D
054E:  MOVLW  AA
054F:  MOVWF  0D
0550:  BSF    0C.1
0551:  BTFSC  0C.1
0552:  GOTO   551
0553:  BCF    0C.2
0554:  MOVF   77,W
0555:  BCF    03.5
0556:  BCF    03.6
0557:  IORWF  0B,F
....................    access_address++; 
0558:  INCF   58,F
0559:  BTFSC  03.2
055A:  INCF   59,F
....................    write_regist_memory(access_address, year_high); 
055B:  MOVLW  80
055C:  ADDWF  58,W
055D:  BSF    03.6
055E:  MOVWF  42
055F:  BCF    03.6
0560:  MOVF   59,W
0561:  BSF    03.6
0562:  MOVWF  43
0563:  BTFSC  03.0
0564:  INCF   43,F
0565:  MOVF   42,W
0566:  MOVWF  0D
0567:  BCF    03.6
0568:  MOVF   2D,W
0569:  BSF    03.6
056A:  MOVWF  0C
056B:  BSF    03.5
056C:  BCF    0C.7
056D:  BSF    0C.2
056E:  BCF    03.5
056F:  BCF    03.6
0570:  MOVF   0B,W
0571:  MOVWF  77
0572:  BCF    0B.7
0573:  BSF    03.5
0574:  BSF    03.6
0575:  MOVLW  55
0576:  MOVWF  0D
0577:  MOVLW  AA
0578:  MOVWF  0D
0579:  BSF    0C.1
057A:  BTFSC  0C.1
057B:  GOTO   57A
057C:  BCF    0C.2
057D:  MOVF   77,W
057E:  BCF    03.5
057F:  BCF    03.6
0580:  IORWF  0B,F
....................    access_address++; 
0581:  INCF   58,F
0582:  BTFSC  03.2
0583:  INCF   59,F
.................... 	write_regist_memory(access_address, year_low); 
0584:  MOVLW  80
0585:  ADDWF  58,W
0586:  BSF    03.6
0587:  MOVWF  42
0588:  BCF    03.6
0589:  MOVF   59,W
058A:  BSF    03.6
058B:  MOVWF  43
058C:  BTFSC  03.0
058D:  INCF   43,F
058E:  MOVF   42,W
058F:  MOVWF  0D
0590:  BCF    03.6
0591:  MOVF   2E,W
0592:  BSF    03.6
0593:  MOVWF  0C
0594:  BSF    03.5
0595:  BCF    0C.7
0596:  BSF    0C.2
0597:  BCF    03.5
0598:  BCF    03.6
0599:  MOVF   0B,W
059A:  MOVWF  77
059B:  BCF    0B.7
059C:  BSF    03.5
059D:  BSF    03.6
059E:  MOVLW  55
059F:  MOVWF  0D
05A0:  MOVLW  AA
05A1:  MOVWF  0D
05A2:  BSF    0C.1
05A3:  BTFSC  0C.1
05A4:  GOTO   5A3
05A5:  BCF    0C.2
05A6:  MOVF   77,W
05A7:  BCF    03.5
05A8:  BCF    03.6
05A9:  IORWF  0B,F
....................    access_address++; 
05AA:  INCF   58,F
05AB:  BTFSC  03.2
05AC:  INCF   59,F
....................    write_regist_memory(access_address, current_door); 
05AD:  MOVLW  80
05AE:  ADDWF  58,W
05AF:  BSF    03.6
05B0:  MOVWF  42
05B1:  BCF    03.6
05B2:  MOVF   59,W
05B3:  BSF    03.6
05B4:  MOVWF  43
05B5:  BTFSC  03.0
05B6:  INCF   43,F
05B7:  MOVLW  00
05B8:  BCF    03.6
05B9:  BTFSC  2F.0
05BA:  MOVLW  01
05BB:  BSF    03.6
05BC:  MOVWF  44
05BD:  MOVF   42,W
05BE:  MOVWF  0D
05BF:  MOVF   44,W
05C0:  MOVWF  0C
05C1:  BSF    03.5
05C2:  BCF    0C.7
05C3:  BSF    0C.2
05C4:  BCF    03.5
05C5:  BCF    03.6
05C6:  MOVF   0B,W
05C7:  MOVWF  77
05C8:  BCF    0B.7
05C9:  BSF    03.5
05CA:  BSF    03.6
05CB:  MOVLW  55
05CC:  MOVWF  0D
05CD:  MOVLW  AA
05CE:  MOVWF  0D
05CF:  BSF    0C.1
05D0:  BTFSC  0C.1
05D1:  GOTO   5D0
05D2:  BCF    0C.2
05D3:  MOVF   77,W
05D4:  BCF    03.5
05D5:  BCF    03.6
05D6:  IORWF  0B,F
....................    access_address++; 
05D7:  INCF   58,F
05D8:  BTFSC  03.2
05D9:  INCF   59,F
....................     
....................    real_time(minutes, hours, date, mounth, year_low); 
....................     
....................    access_event_count++; 
*
067B:  BCF    03.5
067C:  INCF   5A,F
....................    if(access_address == access_event_count * 8 - 1){ 
067D:  RLF    5A,W
067E:  MOVWF  77
067F:  RLF    77,F
0680:  RLF    77,F
0681:  MOVLW  F8
0682:  ANDWF  77,F
0683:  MOVF   77,W
0684:  ADDLW  FF
0685:  SUBWF  58,W
0686:  BTFSS  03.2
0687:  GOTO   68F
0688:  MOVF   59,F
0689:  BTFSS  03.2
068A:  GOTO   68F
....................       access_address = 2; 
068B:  CLRF   59
068C:  MOVLW  02
068D:  MOVWF  58
.................... 	  access_event_count = 0; 
068E:  CLRF   5A
....................    } 
....................    write_regist_memory(1, access_event_count); 
068F:  MOVLW  81
0690:  BSF    03.6
0691:  MOVWF  0D
0692:  BCF    03.6
0693:  MOVF   5A,W
0694:  BSF    03.6
0695:  MOVWF  0C
0696:  BSF    03.5
0697:  BCF    0C.7
0698:  BSF    0C.2
0699:  BCF    03.5
069A:  BCF    03.6
069B:  MOVF   0B,W
069C:  MOVWF  77
069D:  BCF    0B.7
069E:  BSF    03.5
069F:  BSF    03.6
06A0:  MOVLW  55
06A1:  MOVWF  0D
06A2:  MOVLW  AA
06A3:  MOVWF  0D
06A4:  BSF    0C.1
06A5:  BTFSC  0C.1
06A6:  GOTO   6A5
06A7:  BCF    0C.2
06A8:  MOVF   77,W
06A9:  BCF    03.5
06AA:  BCF    03.6
06AB:  IORWF  0B,F
.................... } 
06AC:  RETURN
....................  
.................... //Funcion que busca un codigo dentro de la lista blanca 
.................... short find_user(int &facCode, long &userCode) 
.................... { 
....................    int read; 
....................    int FacilityCode; 
....................    long IdCardCode; 
....................    int access; 
....................    address = 2;                
*
0B31:  BCF    03.6
0B32:  CLRF   57
0B33:  MOVLW  02
0B34:  MOVWF  56
....................           
....................    //Aqui primero hay que actualizar el userCount leyendo la posicion 1 de la memoria 
....................    int user_count = read_white_memory(1);  
0B35:  MOVLW  01
0B36:  BSF    03.6
0B37:  MOVWF  0D
0B38:  BSF    03.5
0B39:  BCF    0C.7
0B3A:  BSF    0C.0
0B3B:  BCF    03.5
0B3C:  MOVF   0C,W
0B3D:  MOVWF  39
....................     
....................    //Recorriendo la memoria de codigos 
....................    for(user = 0; user < user_count; user++){  
0B3E:  BCF    03.6
0B3F:  CLRF   30
0B40:  BSF    03.6
0B41:  MOVF   39,W
0B42:  BCF    03.6
0B43:  SUBWF  30,W
0B44:  BTFSC  03.0
0B45:  GOTO   3B6
....................       IdCardCode = 0; 
0B46:  BSF    03.6
0B47:  CLRF   37
0B48:  CLRF   36
....................       //Obteniendo el FacilityCode (1er byte del bloque que ocupa el codigo en la memoria I2C) 
....................       FacilityCode = read_white_memory(address); 
0B49:  BCF    03.6
0B4A:  MOVF   56,W
0B4B:  BSF    03.6
0B4C:  MOVWF  0D
0B4D:  BSF    03.5
0B4E:  BCF    0C.7
0B4F:  BSF    0C.0
0B50:  BCF    03.5
0B51:  MOVF   0C,W
0B52:  MOVWF  35
....................       address++; 
0B53:  BCF    03.6
0B54:  INCF   56,F
0B55:  BTFSC  03.2
0B56:  INCF   57,F
....................       //Obteniendo el UserCode (Sgtes 2 bytes del bloque que ocupa el codigo en la memoria I2C) 
....................       read = read_white_memory(address);     
0B57:  MOVF   56,W
0B58:  BSF    03.6
0B59:  MOVWF  0D
0B5A:  BSF    03.5
0B5B:  BCF    0C.7
0B5C:  BSF    0C.0
0B5D:  BCF    03.5
0B5E:  MOVF   0C,W
0B5F:  MOVWF  34
....................       address++; 
0B60:  BCF    03.6
0B61:  INCF   56,F
0B62:  BTFSC  03.2
0B63:  INCF   57,F
....................       IdCardCode = read * 256; 
0B64:  CLRF   7A
0B65:  BSF    03.6
0B66:  MOVF   34,W
0B67:  MOVWF  37
0B68:  CLRF   36
....................       read = read_white_memory(address);     
0B69:  BCF    03.6
0B6A:  MOVF   56,W
0B6B:  BSF    03.6
0B6C:  MOVWF  0D
0B6D:  BSF    03.5
0B6E:  BCF    0C.7
0B6F:  BSF    0C.0
0B70:  BCF    03.5
0B71:  MOVF   0C,W
0B72:  MOVWF  34
....................       address++; 
0B73:  BCF    03.6
0B74:  INCF   56,F
0B75:  BTFSC  03.2
0B76:  INCF   57,F
....................       IdCardCode += read; 
0B77:  BSF    03.6
0B78:  MOVF   34,W
0B79:  ADDWF  36,F
0B7A:  BTFSC  03.0
0B7B:  INCF   37,F
....................       //Obteniendo la politica de acceso (Ultimo byte del bloque que ocupa el codigo en la memoria I2C) 
....................       access = read_white_memory(address); 
0B7C:  BCF    03.6
0B7D:  MOVF   56,W
0B7E:  BSF    03.6
0B7F:  MOVWF  0D
0B80:  BSF    03.5
0B81:  BCF    0C.7
0B82:  BSF    0C.0
0B83:  BCF    03.5
0B84:  MOVF   0C,W
0B85:  MOVWF  38
....................       address++; 
0B86:  BCF    03.6
0B87:  INCF   56,F
0B88:  BTFSC  03.2
0B89:  INCF   57,F
....................       //Comparando  
....................       if(facCode == FacilityCode && userCode == IdCardCode){ 
0B8A:  BSF    03.6
0B8B:  MOVF   35,W
0B8C:  SUBWF  30,W
0B8D:  BTFSS  03.2
0B8E:  GOTO   3B3
0B8F:  MOVF   36,W
0B90:  SUBWF  31,W
0B91:  BTFSS  03.2
0B92:  GOTO   3B3
0B93:  MOVF   37,W
0B94:  SUBWF  32,W
0B95:  BTFSS  03.2
0B96:  GOTO   3B3
.................... 		switch(access){ 
0B97:  MOVF   38,W
0B98:  XORLW  01
0B99:  BCF    03.6
0B9A:  BTFSC  03.2
0B9B:  GOTO   3A3
0B9C:  XORLW  03
0B9D:  BTFSC  03.2
0B9E:  GOTO   3A9
0B9F:  XORLW  01
0BA0:  BTFSC  03.2
0BA1:  GOTO   3AF
0BA2:  GOTO   3B2
.................... 			case 1: 
.................... 				if(current_door == 0) 
0BA3:  BTFSC  2F.0
0BA4:  GOTO   3A8
.................... 					return 1; 
0BA5:  MOVLW  01
0BA6:  MOVWF  78
0BA7:  GOTO   3BA
.................... 				break; 
0BA8:  GOTO   3B2
.................... 			case 2: 
.................... 				if(current_door == 1) 
0BA9:  BTFSS  2F.0
0BAA:  GOTO   3AE
.................... 					return 1; 
0BAB:  MOVLW  01
0BAC:  MOVWF  78
0BAD:  GOTO   3BA
.................... 				break; 
0BAE:  GOTO   3B2
.................... 			case 3: 
.................... 				return 1; 
0BAF:  MOVLW  01
0BB0:  MOVWF  78
0BB1:  GOTO   3BA
0BB2:  BSF    03.6
.................... 		}    
.................... 	  } 
.................... 	} 
0BB3:  BCF    03.6
0BB4:  INCF   30,F
0BB5:  GOTO   340
.................... 	user = 254;	//Acceso denegado 
0BB6:  MOVLW  FE
0BB7:  MOVWF  30
.................... 	return 0; 
0BB8:  MOVLW  00
0BB9:  MOVWF  78
.................... } 
....................  
.................... //Interrupcion externa utilizada para el rex      
.................... #int_ext 
.................... void intRB0_handler() 
.................... { 
....................    current_door = 0; 
*
06D2:  BCF    2F.0
....................    user = 255;	//REX 
06D3:  MOVLW  FF
06D4:  MOVWF  30
....................    regist(); 
06D5:  CALL   3EC
....................    handle_door(); 
06D6:  CALL   6AD
.................... } 
....................      
.................... //Interrupcion por timer1 utilizada para volver a bloquear la puerta despues de producirse un accceso 
06D7:  BCF    0B.1
06D8:  BCF    0A.3
06D9:  BCF    0A.4
06DA:  GOTO   031
.................... #int_timer1 
.................... void timer1() 
.................... { 
.................... 	if(time_counter < 5) 
06DB:  MOVF   31,W
06DC:  SUBLW  04
06DD:  BTFSS  03.0
06DE:  GOTO   6E1
.................... 		time_counter++; 
06DF:  INCF   31,F
.................... 	else{ 
06E0:  GOTO   702
.................... 		time_counter = 0; 
06E1:  CLRF   31
....................    		if(current_door){   //Puerta 1 
06E2:  BTFSS  2F.0
06E3:  GOTO   6F1
....................       		output_low(green_led_door_1); 
06E4:  BSF    03.5
06E5:  BCF    05.1
06E6:  BCF    03.5
06E7:  BCF    05.1
.................... 	  		output_high(red_led_door_1); 
06E8:  BSF    03.5
06E9:  BCF    05.2
06EA:  BCF    03.5
06EB:  BSF    05.2
.................... 	  		output_low(open_door_1); 
06EC:  BSF    03.5
06ED:  BCF    05.3
06EE:  BCF    03.5
06EF:  BCF    05.3
....................    		} 
....................    		else{ //Puerta 0 
06F0:  GOTO   6FF
....................       		output_low(green_led_door_0); 
06F1:  BSF    03.5
06F2:  BCF    08.1
06F3:  BCF    03.5
06F4:  BCF    08.1
....................       		output_high(red_led_door_0); 
06F5:  BSF    03.5
06F6:  BCF    08.2
06F7:  BCF    03.5
06F8:  BSF    08.2
....................       		output_low(open_door_0); 
06F9:  BCF    55.5
06FA:  MOVF   55,W
06FB:  BSF    03.5
06FC:  MOVWF  07
06FD:  BCF    03.5
06FE:  BCF    07.5
....................    		} 
....................    		disable_interrupts(int_timer1); 
06FF:  BSF    03.5
0700:  BCF    0C.0
0701:  BCF    03.5
.................... 	} 
.................... } 
....................  
0702:  BCF    0C.0
0703:  BCF    0A.3
0704:  BCF    0A.4
0705:  GOTO   031
.................... void main()  
.................... { 
*
09E1:  CLRF   04
09E2:  BCF    03.7
09E3:  MOVLW  1F
09E4:  ANDWF  03,F
09E5:  MOVLW  14
09E6:  MOVWF  2D
09E7:  CLRF   31
09E8:  CLRF   34
09E9:  CLRF   33
09EA:  CLRF   35
09EB:  BCF    2F.1
09EC:  CLRF   51
09ED:  MOVLW  19
09EE:  BSF    03.5
09EF:  MOVWF  19
09F0:  MOVLW  A6
09F1:  MOVWF  18
09F2:  MOVLW  90
09F3:  BCF    03.5
09F4:  MOVWF  18
09F5:  BCF    2F.3
09F6:  CLRF   52
09F7:  MOVLW  FF
09F8:  MOVWF  55
09F9:  CLRF   57
09FA:  CLRF   56
09FB:  CLRF   59
09FC:  MOVLW  02
09FD:  MOVWF  58
09FE:  CLRF   5A
09FF:  BSF    03.5
0A00:  BSF    1F.0
0A01:  BSF    1F.1
0A02:  BSF    1F.2
0A03:  BCF    1F.3
0A04:  MOVLW  07
0A05:  MOVWF  1C
0A06:  BCF    03.5
0A07:  BSF    03.6
0A08:  CLRF   32
0A09:  CLRF   31
....................   int facCode;  
....................   long userCode = 0; 
....................   //int MODBUS_ADDRESS = get_modbus_address(); 
....................  
....................   modbus_init(); 
0A0A:  BCF    0A.3
0A0B:  BCF    03.6
0A0C:  GOTO   70F
0A0D:  BSF    0A.3
....................   wiegand_init(); 
0A0E:  BCF    0A.3
0A0F:  GOTO   72E
0A10:  BSF    0A.3
....................   //lcd_init(); 
....................    
....................   clean_registers(); 
0A11:  BCF    0A.3
0A12:  CALL   738
0A13:  BSF    0A.3
....................   clean_white_memory(); 
0A14:  BCF    0A.3
0A15:  GOTO   771
0A16:  BSF    0A.3
....................  
....................   minutes = 8; 
0A17:  MOVLW  08
0A18:  MOVWF  29
....................   hours = 8;  
0A19:  MOVWF  2A
....................   date = 9;  
0A1A:  MOVLW  09
0A1B:  MOVWF  2B
....................   mounth = 1;  
0A1C:  MOVLW  01
0A1D:  MOVWF  2C
....................   year_low = 14; 
0A1E:  MOVLW  0E
0A1F:  MOVWF  2E
....................   rtc_init(minutes, hours, date, mounth, year_low); 
0A20:  MOVF   29,W
0A21:  BSF    03.6
0A22:  MOVWF  34
0A23:  BCF    03.6
0A24:  MOVF   2A,W
0A25:  BSF    03.6
0A26:  MOVWF  35
0A27:  BCF    03.6
0A28:  MOVF   2B,W
0A29:  BSF    03.6
0A2A:  MOVWF  36
0A2B:  BCF    03.6
0A2C:  MOVF   2C,W
0A2D:  BSF    03.6
0A2E:  MOVWF  37
0A2F:  BCF    03.6
0A30:  MOVF   2E,W
0A31:  BSF    03.6
0A32:  MOVWF  38
0A33:  BCF    03.6
0A34:  CALL   000
....................  
....................   write_white_memory(0, 0); 
0A35:  BSF    03.6
0A36:  CLRF   0D
0A37:  CLRF   0C
0A38:  BSF    03.5
0A39:  BCF    0C.7
0A3A:  BSF    0C.2
0A3B:  BCF    03.5
0A3C:  BCF    03.6
0A3D:  MOVF   0B,W
0A3E:  MOVWF  77
0A3F:  BCF    0B.7
0A40:  BSF    03.5
0A41:  BSF    03.6
0A42:  MOVLW  55
0A43:  MOVWF  0D
0A44:  MOVLW  AA
0A45:  MOVWF  0D
0A46:  BSF    0C.1
0A47:  BTFSC  0C.1
0A48:  GOTO   247
0A49:  BCF    0C.2
0A4A:  MOVF   77,W
0A4B:  BCF    03.5
0A4C:  BCF    03.6
0A4D:  IORWF  0B,F
....................   write_white_memory(1, 1); 
0A4E:  MOVLW  01
0A4F:  BSF    03.6
0A50:  MOVWF  0D
0A51:  MOVWF  0C
0A52:  BSF    03.5
0A53:  BCF    0C.7
0A54:  BSF    0C.2
0A55:  BCF    03.5
0A56:  BCF    03.6
0A57:  MOVF   0B,W
0A58:  MOVWF  77
0A59:  BCF    0B.7
0A5A:  BSF    03.5
0A5B:  BSF    03.6
0A5C:  MOVLW  55
0A5D:  MOVWF  0D
0A5E:  MOVLW  AA
0A5F:  MOVWF  0D
0A60:  BSF    0C.1
0A61:  BTFSC  0C.1
0A62:  GOTO   261
0A63:  BCF    0C.2
0A64:  MOVF   77,W
0A65:  BCF    03.5
0A66:  BCF    03.6
0A67:  IORWF  0B,F
....................   write_white_memory(2, 1); 
0A68:  MOVLW  02
0A69:  BSF    03.6
0A6A:  MOVWF  0D
0A6B:  MOVLW  01
0A6C:  MOVWF  0C
0A6D:  BSF    03.5
0A6E:  BCF    0C.7
0A6F:  BSF    0C.2
0A70:  BCF    03.5
0A71:  BCF    03.6
0A72:  MOVF   0B,W
0A73:  MOVWF  77
0A74:  BCF    0B.7
0A75:  BSF    03.5
0A76:  BSF    03.6
0A77:  MOVLW  55
0A78:  MOVWF  0D
0A79:  MOVLW  AA
0A7A:  MOVWF  0D
0A7B:  BSF    0C.1
0A7C:  BTFSC  0C.1
0A7D:  GOTO   27C
0A7E:  BCF    0C.2
0A7F:  MOVF   77,W
0A80:  BCF    03.5
0A81:  BCF    03.6
0A82:  IORWF  0B,F
....................   write_white_memory(3, 0x5B); 
0A83:  MOVLW  03
0A84:  BSF    03.6
0A85:  MOVWF  0D
0A86:  MOVLW  5B
0A87:  MOVWF  0C
0A88:  BSF    03.5
0A89:  BCF    0C.7
0A8A:  BSF    0C.2
0A8B:  BCF    03.5
0A8C:  BCF    03.6
0A8D:  MOVF   0B,W
0A8E:  MOVWF  77
0A8F:  BCF    0B.7
0A90:  BSF    03.5
0A91:  BSF    03.6
0A92:  MOVLW  55
0A93:  MOVWF  0D
0A94:  MOVLW  AA
0A95:  MOVWF  0D
0A96:  BSF    0C.1
0A97:  BTFSC  0C.1
0A98:  GOTO   297
0A99:  BCF    0C.2
0A9A:  MOVF   77,W
0A9B:  BCF    03.5
0A9C:  BCF    03.6
0A9D:  IORWF  0B,F
....................   write_white_memory(4, 0xA0); 
0A9E:  MOVLW  04
0A9F:  BSF    03.6
0AA0:  MOVWF  0D
0AA1:  MOVLW  A0
0AA2:  MOVWF  0C
0AA3:  BSF    03.5
0AA4:  BCF    0C.7
0AA5:  BSF    0C.2
0AA6:  BCF    03.5
0AA7:  BCF    03.6
0AA8:  MOVF   0B,W
0AA9:  MOVWF  77
0AAA:  BCF    0B.7
0AAB:  BSF    03.5
0AAC:  BSF    03.6
0AAD:  MOVLW  55
0AAE:  MOVWF  0D
0AAF:  MOVLW  AA
0AB0:  MOVWF  0D
0AB1:  BSF    0C.1
0AB2:  BTFSC  0C.1
0AB3:  GOTO   2B2
0AB4:  BCF    0C.2
0AB5:  MOVF   77,W
0AB6:  BCF    03.5
0AB7:  BCF    03.6
0AB8:  IORWF  0B,F
....................   write_white_memory(5, 3); 
0AB9:  MOVLW  05
0ABA:  BSF    03.6
0ABB:  MOVWF  0D
0ABC:  MOVLW  03
0ABD:  MOVWF  0C
0ABE:  BSF    03.5
0ABF:  BCF    0C.7
0AC0:  BSF    0C.2
0AC1:  BCF    03.5
0AC2:  BCF    03.6
0AC3:  MOVF   0B,W
0AC4:  MOVWF  77
0AC5:  BCF    0B.7
0AC6:  BSF    03.5
0AC7:  BSF    03.6
0AC8:  MOVLW  55
0AC9:  MOVWF  0D
0ACA:  MOVLW  AA
0ACB:  MOVWF  0D
0ACC:  BSF    0C.1
0ACD:  BTFSC  0C.1
0ACE:  GOTO   2CD
0ACF:  BCF    0C.2
0AD0:  MOVF   77,W
0AD1:  BCF    03.5
0AD2:  BCF    03.6
0AD3:  IORWF  0B,F
....................                       
....................   //Inicializando las salidas  
....................   output_low(green_led_door_0); 
0AD4:  BSF    03.5
0AD5:  BCF    08.1
0AD6:  BCF    03.5
0AD7:  BCF    08.1
....................   output_high(red_led_door_0); 
0AD8:  BSF    03.5
0AD9:  BCF    08.2
0ADA:  BCF    03.5
0ADB:  BSF    08.2
....................   /*output_low(open_door_0); 
....................   output_low(green_led_door_1); 
....................   output_high(red_led_door_1); 
....................   output_low(open_door_1); 
....................   output_low(buzzer_door_0); 
....................   output_low(buzzer_door_1);*/ 
....................      
....................   setup_adc_ports(NO_ANALOGS); 
0ADC:  BSF    03.5
0ADD:  BSF    1F.0
0ADE:  BSF    1F.1
0ADF:  BSF    1F.2
0AE0:  BCF    1F.3
....................   port_b_pullups(true); 
0AE1:  BCF    01.7
....................   setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
0AE2:  MOVLW  B5
0AE3:  BCF    03.5
0AE4:  MOVWF  10
....................    
....................   //Habilitando interrupciones 
....................   enable_interrupts(int_ext); 
0AE5:  BSF    0B.4
....................   ext_int_edge(H_TO_L); 
0AE6:  BSF    03.5
0AE7:  BCF    01.6
....................   enable_interrupts(global); 
0AE8:  MOVLW  C0
0AE9:  BCF    03.5
0AEA:  IORWF  0B,F
....................    
....................   while (TRUE){ 
....................    
....................       if(receive_wiegand()){ 
0AEB:  GOTO   0DA
0AEC:  MOVF   78,F
0AED:  BTFSC  03.2
0AEE:  GOTO   3C9
....................          current_door = get_door(); 
0AEF:  BCF    0A.3
0AF0:  GOTO   7D6
0AF1:  BSF    0A.3
0AF2:  BCF    2F.0
0AF3:  BTFSC  78.0
0AF4:  BSF    2F.0
....................          if(current_door){ 
0AF5:  BTFSS  2F.0
0AF6:  GOTO   30D
....................             output_high(buzzer_door_1); 
0AF7:  BSF    03.5
0AF8:  BCF    05.4
0AF9:  BCF    03.5
0AFA:  BSF    05.4
....................             delay_ms(500); 
0AFB:  MOVLW  02
0AFC:  BSF    03.6
0AFD:  MOVWF  34
0AFE:  MOVLW  FA
0AFF:  MOVWF  35
0B00:  BCF    0A.3
0B01:  BCF    03.6
0B02:  CALL   7DD
0B03:  BSF    0A.3
0B04:  BSF    03.6
0B05:  DECFSZ 34,F
0B06:  GOTO   2FE
....................             output_low(buzzer_door_1); 
0B07:  BSF    03.5
0B08:  BCF    03.6
0B09:  BCF    05.4
0B0A:  BCF    03.5
0B0B:  BCF    05.4
....................          } 
....................          else{ 
0B0C:  GOTO   326
....................             output_high(buzzer_door_0); 
0B0D:  BCF    55.2
0B0E:  MOVF   55,W
0B0F:  BSF    03.5
0B10:  MOVWF  07
0B11:  BCF    03.5
0B12:  BSF    07.2
....................             delay_ms(500); 
0B13:  MOVLW  02
0B14:  BSF    03.6
0B15:  MOVWF  34
0B16:  MOVLW  FA
0B17:  MOVWF  35
0B18:  BCF    0A.3
0B19:  BCF    03.6
0B1A:  CALL   7DD
0B1B:  BSF    0A.3
0B1C:  BSF    03.6
0B1D:  DECFSZ 34,F
0B1E:  GOTO   316
....................             output_low(buzzer_door_0); 
0B1F:  BCF    03.6
0B20:  BCF    55.2
0B21:  MOVF   55,W
0B22:  BSF    03.5
0B23:  MOVWF  07
0B24:  BCF    03.5
0B25:  BCF    07.2
....................          } 
....................           
....................          get_code(facCode, userCode); 
....................          if(find_user(facCode, userCode)) 
*
0BBA:  MOVF   78,F
0BBB:  BTFSC  03.2
0BBC:  GOTO   3C0
.................... 			handle_door(); 
0BBD:  BCF    0A.3
0BBE:  CALL   6AD
0BBF:  BSF    0A.3
0BC0:  CLRF   27
0BC1:  BTFSC  0B.7
0BC2:  BSF    27.7
0BC3:  BCF    0B.7
.................... 		 regist(); 
0BC4:  BCF    0A.3
0BC5:  CALL   3EC
0BC6:  BSF    0A.3
0BC7:  BTFSC  27.7
0BC8:  BSF    0B.7
....................       } 
....................           
....................       if(modbus_kbhit()){ 
0BC9:  GOTO   127
0BCA:  MOVF   78,F
0BCB:  BTFSC  03.2
0BCC:  GOTO   5E9
....................          delay_us(50); 
0BCD:  MOVLW  10
0BCE:  MOVWF  77
0BCF:  DECFSZ 77,F
0BD0:  GOTO   3CF
0BD1:  NOP
....................          //check address against our address, 0 is broadcast 
....................          if((modbus_rx.address == MODBUS_ADDRESS) || modbus_rx.address == 0) 
0BD2:  BSF    03.5
0BD3:  DECFSZ 20,W
0BD4:  GOTO   3D6
0BD5:  GOTO   3D9
0BD6:  MOVF   20,F
0BD7:  BTFSS  03.2
0BD8:  GOTO   5EA
....................          { 
....................             switch(modbus_rx.func) 
....................             { 
0BD9:  MOVF   22,W
0BDA:  XORLW  05
0BDB:  BCF    03.5
0BDC:  BTFSC  03.2
0BDD:  GOTO   3E8
0BDE:  XORLW  06
0BDF:  BTFSC  03.2
0BE0:  GOTO   424
0BE1:  XORLW  07
0BE2:  BTFSC  03.2
0BE3:  GOTO   480
0BE4:  XORLW  14
0BE5:  BTFSC  03.2
0BE6:  GOTO   4DC
0BE7:  GOTO   5CB
.................... 			   case FUNC_WRITE_SINGLE_COIL:	//Esta funcion se utiliza para limpiar los registros 
.................... 				  clean_registers(); 
0BE8:  BCF    0A.3
0BE9:  CALL   738
0BEA:  BSF    0A.3
.................... 				  modbus_write_single_coil_rsp(MODBUS_ADDRESS,modbus_rx.data[1],((int16)(modbus_rx.data[2]))<<8); 
0BEB:  BSF    03.6
0BEC:  CLRF   35
0BED:  BSF    03.5
0BEE:  BCF    03.6
0BEF:  MOVF   26,W
0BF0:  BCF    03.5
0BF1:  BSF    03.6
0BF2:  MOVWF  34
0BF3:  MOVF   34,W
0BF4:  MOVWF  35
0BF5:  CLRF   34
0BF6:  MOVLW  01
0BF7:  MOVWF  36
0BF8:  CLRF   38
0BF9:  BSF    03.5
0BFA:  BCF    03.6
0BFB:  MOVF   25,W
0BFC:  BCF    03.5
0BFD:  BSF    03.6
0BFE:  MOVWF  37
0BFF:  MOVF   35,W
0C00:  MOVWF  3A
0C01:  MOVF   34,W
0C02:  MOVWF  39
.................... 				  break; 
*
0C23:  GOTO   5E9
.................... 			   case FUNC_READ_HOLDING_REGISTERS:	//Esta funcion sera utilizada para leer la lista blanca 
....................                   conf_data(modbus_rx.data[1],modbus_rx.data[3]); 
0C24:  BSF    03.5
0C25:  MOVF   25,W
0C26:  BCF    03.5
0C27:  BSF    03.6
0C28:  MOVWF  34
0C29:  BSF    03.5
0C2A:  BCF    03.6
0C2B:  MOVF   27,W
0C2C:  BCF    03.5
0C2D:  BSF    03.6
0C2E:  MOVWF  35
0C2F:  BCF    03.6
0C30:  GOTO   189
....................                   modbus_read_holding_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),mbus_data); 
0C31:  BCF    03.0
0C32:  BSF    03.5
0C33:  RLF    27,W
0C34:  BCF    03.5
0C35:  BSF    03.6
0C36:  MOVWF  34
0C37:  MOVLW  01
0C38:  MOVWF  35
0C39:  MOVF   34,W
0C3A:  MOVWF  36
0C3B:  MOVLW  01
0C3C:  MOVWF  38
0C3D:  MOVLW  10
0C3E:  MOVWF  37
....................                   break; 
*
0C7F:  GOTO   5E9
....................                case FUNC_READ_INPUT_REGISTERS:	//Esta funcion sera utilizada para leer los registros de accesos producidos 
....................                   regist_data(modbus_rx.data[1],modbus_rx.data[3]); 
0C80:  BSF    03.5
0C81:  MOVF   25,W
0C82:  BCF    03.5
0C83:  BSF    03.6
0C84:  MOVWF  34
0C85:  BSF    03.5
0C86:  BCF    03.6
0C87:  MOVF   27,W
0C88:  BCF    03.5
0C89:  BSF    03.6
0C8A:  MOVWF  35
0C8B:  BCF    03.6
0C8C:  GOTO   1B2
....................                   modbus_read_input_registers_rsp(MODBUS_ADDRESS,(modbus_rx.data[3]*2),mbus_data); 
0C8D:  BCF    03.0
0C8E:  BSF    03.5
0C8F:  RLF    27,W
0C90:  BCF    03.5
0C91:  BSF    03.6
0C92:  MOVWF  34
0C93:  MOVLW  01
0C94:  MOVWF  35
0C95:  MOVF   34,W
0C96:  MOVWF  36
0C97:  MOVLW  01
0C98:  MOVWF  38
0C99:  MOVLW  10
0C9A:  MOVWF  37
.................... 				  break; 
*
0CDB:  GOTO   5E9
....................                case FUNC_WRITE_MULTIPLE_REGISTERS:	//Esta funcion sera utilizada para actualizar la lista blanca asi como la fecha y hora 
.................... 				  //Actualizando la hora  
.................... 				  minutes = modbus_rx.data[5]; 
0CDC:  BSF    03.5
0CDD:  MOVF   29,W
0CDE:  BCF    03.5
0CDF:  MOVWF  29
.................... 				  hours = modbus_rx.data[6]; 
0CE0:  BSF    03.5
0CE1:  MOVF   2A,W
0CE2:  BCF    03.5
0CE3:  MOVWF  2A
.................... 				  date = modbus_rx.data[7]; 
0CE4:  BSF    03.5
0CE5:  MOVF   2B,W
0CE6:  BCF    03.5
0CE7:  MOVWF  2B
.................... 				  mounth = modbus_rx.data[8]; 
0CE8:  BSF    03.5
0CE9:  MOVF   2C,W
0CEA:  BCF    03.5
0CEB:  MOVWF  2C
.................... 				  year_high = modbus_rx.data[9]; 
0CEC:  BSF    03.5
0CED:  MOVF   2D,W
0CEE:  BCF    03.5
0CEF:  MOVWF  2D
.................... 				  year_low = modbus_rx.data[10]; 
0CF0:  BSF    03.5
0CF1:  MOVF   2E,W
0CF2:  BCF    03.5
0CF3:  MOVWF  2E
.................... 				  rtc_init(minutes, hours, date, mounth, year_low);  
0CF4:  MOVF   29,W
0CF5:  BSF    03.6
0CF6:  MOVWF  34
0CF7:  BCF    03.6
0CF8:  MOVF   2A,W
0CF9:  BSF    03.6
0CFA:  MOVWF  35
0CFB:  BCF    03.6
0CFC:  MOVF   2B,W
0CFD:  BSF    03.6
0CFE:  MOVWF  36
0CFF:  BCF    03.6
0D00:  MOVF   2C,W
0D01:  BSF    03.6
0D02:  MOVWF  37
0D03:  BCF    03.6
0D04:  MOVF   2E,W
0D05:  BSF    03.6
0D06:  MOVWF  38
0D07:  BCF    03.6
0D08:  CALL   000
.................... 				  //Actualizando la memoria de lista blanca 
.................... 				  address = modbus_rx.data[1] * 2; //un registro modbus contiene dos registros de memoria de codigos 
0D09:  BCF    03.0
0D0A:  BSF    03.5
0D0B:  RLF    25,W
0D0C:  BCF    03.5
0D0D:  MOVWF  56
0D0E:  CLRF   57
0D0F:  BTFSC  03.0
0D10:  INCF   57,F
.................... 				  //Poniendo la cantidad de usuarios de codigo 
.................... 				  write_white_memory(address, modbus_rx.data[11]); 
0D11:  MOVF   56,W
0D12:  BSF    03.6
0D13:  MOVWF  0D
0D14:  BSF    03.5
0D15:  BCF    03.6
0D16:  MOVF   2F,W
0D17:  BCF    03.5
0D18:  BSF    03.6
0D19:  MOVWF  0C
0D1A:  BSF    03.5
0D1B:  BCF    0C.7
0D1C:  BSF    0C.2
0D1D:  BCF    03.5
0D1E:  BCF    03.6
0D1F:  MOVF   0B,W
0D20:  MOVWF  77
0D21:  BCF    0B.7
0D22:  BSF    03.5
0D23:  BSF    03.6
0D24:  MOVLW  55
0D25:  MOVWF  0D
0D26:  MOVLW  AA
0D27:  MOVWF  0D
0D28:  BSF    0C.1
0D29:  BTFSC  0C.1
0D2A:  GOTO   529
0D2B:  BCF    0C.2
0D2C:  MOVF   77,W
0D2D:  BCF    03.5
0D2E:  BCF    03.6
0D2F:  IORWF  0B,F
....................                   address++; 
0D30:  INCF   56,F
0D31:  BTFSC  03.2
0D32:  INCF   57,F
....................                   write_white_memory(address, modbus_rx.data[12]); 
0D33:  MOVF   56,W
0D34:  BSF    03.6
0D35:  MOVWF  0D
0D36:  BSF    03.5
0D37:  BCF    03.6
0D38:  MOVF   30,W
0D39:  BCF    03.5
0D3A:  BSF    03.6
0D3B:  MOVWF  0C
0D3C:  BSF    03.5
0D3D:  BCF    0C.7
0D3E:  BSF    0C.2
0D3F:  BCF    03.5
0D40:  BCF    03.6
0D41:  MOVF   0B,W
0D42:  MOVWF  77
0D43:  BCF    0B.7
0D44:  BSF    03.5
0D45:  BSF    03.6
0D46:  MOVLW  55
0D47:  MOVWF  0D
0D48:  MOVLW  AA
0D49:  MOVWF  0D
0D4A:  BSF    0C.1
0D4B:  BTFSC  0C.1
0D4C:  GOTO   54B
0D4D:  BCF    0C.2
0D4E:  MOVF   77,W
0D4F:  BCF    03.5
0D50:  BCF    03.6
0D51:  IORWF  0B,F
....................                   address++; 
0D52:  INCF   56,F
0D53:  BTFSC  03.2
0D54:  INCF   57,F
.................... 				  //Poniendo los codigos 
.................... 				  int i; 
.................... 				  for(i = 13; i < modbus_rx.data[4]; i++){ 
0D55:  MOVLW  0D
0D56:  BSF    03.6
0D57:  MOVWF  33
0D58:  BSF    03.5
0D59:  BCF    03.6
0D5A:  MOVF   28,W
0D5B:  BCF    03.5
0D5C:  BSF    03.6
0D5D:  SUBWF  33,W
0D5E:  BTFSC  03.0
0D5F:  GOTO   588
....................                      write_white_memory(address, modbus_rx.data[i]); 
0D60:  MOVLW  A4
0D61:  ADDWF  33,W
0D62:  MOVWF  04
0D63:  BCF    03.7
0D64:  MOVF   00,W
0D65:  MOVWF  34
0D66:  BCF    03.6
0D67:  MOVF   56,W
0D68:  BSF    03.6
0D69:  MOVWF  0D
0D6A:  MOVF   34,W
0D6B:  MOVWF  0C
0D6C:  BSF    03.5
0D6D:  BCF    0C.7
0D6E:  BSF    0C.2
0D6F:  BCF    03.5
0D70:  BCF    03.6
0D71:  MOVF   0B,W
0D72:  MOVWF  77
0D73:  BCF    0B.7
0D74:  BSF    03.5
0D75:  BSF    03.6
0D76:  MOVLW  55
0D77:  MOVWF  0D
0D78:  MOVLW  AA
0D79:  MOVWF  0D
0D7A:  BSF    0C.1
0D7B:  BTFSC  0C.1
0D7C:  GOTO   57B
0D7D:  BCF    0C.2
0D7E:  MOVF   77,W
0D7F:  BCF    03.5
0D80:  BCF    03.6
0D81:  IORWF  0B,F
....................                      address++; 
0D82:  INCF   56,F
0D83:  BTFSC  03.2
0D84:  INCF   57,F
....................                   } 
0D85:  BSF    03.6
0D86:  INCF   33,F
0D87:  GOTO   558
....................                   modbus_write_multiple_registers_rsp(MODBUS_ADDRESS, make16(modbus_rx.data[0],modbus_rx.data[1]), make16(modbus_rx.data[2],modbus_rx.data[3])); 
0D88:  BSF    03.5
0D89:  BCF    03.6
0D8A:  MOVF   24,W
0D8B:  BCF    03.5
0D8C:  BSF    03.6
0D8D:  MOVWF  35
0D8E:  BSF    03.5
0D8F:  BCF    03.6
0D90:  MOVF   25,W
0D91:  BCF    03.5
0D92:  BSF    03.6
0D93:  MOVWF  34
0D94:  BSF    03.5
0D95:  BCF    03.6
0D96:  MOVF   26,W
0D97:  BCF    03.5
0D98:  BSF    03.6
0D99:  MOVWF  37
0D9A:  BSF    03.5
0D9B:  BCF    03.6
0D9C:  MOVF   27,W
0D9D:  BCF    03.5
0D9E:  BSF    03.6
0D9F:  MOVWF  36
0DA0:  MOVLW  01
0DA1:  MOVWF  38
0DA2:  MOVF   35,W
0DA3:  MOVWF  3A
0DA4:  MOVF   34,W
0DA5:  MOVWF  39
0DA6:  MOVF   37,W
0DA7:  MOVWF  3C
0DA8:  MOVF   36,W
0DA9:  MOVWF  3B
....................                   break;  
*
0DCA:  GOTO   5E9
....................                default:    //We don't support the function, so return exception 
....................                   modbus_exception_rsp(MODBUS_ADDRESS,modbus_rx.func,ILLEGAL_FUNCTION); 
0DCB:  MOVLW  01
0DCC:  BSF    03.6
0DCD:  MOVWF  34
0DCE:  CLRF   36
0DCF:  BSF    03.5
0DD0:  BCF    03.6
0DD1:  MOVF   22,W
0DD2:  BCF    03.5
0DD3:  BSF    03.6
0DD4:  MOVWF  35
0DD5:  MOVLW  01
0DD6:  MOVWF  37
....................             } 
....................          } 
....................       } 
....................       /*real_time(minutes, hours, date, mounth, year_low); 
....................       printf(lcd_putc, "\f%u/%u/%u\n%u:%u:%u", date, mounth, year_low, hours, minutes, seconds); 
....................       real_time(minutes, hours, date, mounth, year_low); 
....................       delay_ms(1000);*/ 
....................   } 
*
0DEA:  BCF    03.5
0DEB:  GOTO   2EB
.................... } 
0DEC:  GOTO   5EC

Configuration Fuses:
   Word  1: 373B   RC NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT DEBUG NOPROTECT

   Some fuses have been forced to be compatible with the ICD debugger.
